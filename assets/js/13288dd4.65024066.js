(self.webpackChunkanshulrgoyal=self.webpackChunkanshulrgoyal||[]).push([[8830],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5734:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return c}});var a=t(2122),r=t(9756),i=(t(7294),t(3905)),o=["components"],s={slug:"nodejs-rust-match",title:"Rust and Node.js: A match made in heaven",author:"Anshul Goyal",author_url:"https://github.com/anshulrgoyal",author_image_url:"/img/anshul.jpg",tags:["rust","nodejs"],image:"https://paper-attachments.dropbox.com/s_3C11437A61A671DE930509E35F223D4A57F95F8B98F2408BFA72EA39228306E2_1587462711550_Untitled+design.png"},l=void 0,p={permalink:"/anshulrgoyal/blog/nodejs-rust-match",source:"@site/blog/2020-04-19-rust-and-nodejs.md",title:"Rust and Node.js: A match made in heaven",description:"Table of Contents",date:"2020-04-19T00:00:00.000Z",formattedDate:"April 19, 2020",tags:[{label:"rust",permalink:"/anshulrgoyal/blog/tags/rust"},{label:"nodejs",permalink:"/anshulrgoyal/blog/tags/nodejs"}],readingTime:20.58,truncated:!0,prevItem:{title:"A beginners guide to gRPC with Rust",permalink:"/anshulrgoyal/blog/grpc-rust"},nextItem:{title:"Creating Forms In React With Formik And Yup",permalink:"/anshulrgoyal/blog/react-formik"}},u=[{value:"Table of Contents",id:"table-of-contents",children:[{value:"This article was published at Log Rocket",id:"this-article-was-published-at-log-rocket",children:[]}]},{value:"What is Rust?",id:"what-is-rust",children:[]},{value:"What is a native addon?",id:"what-is-a-native-addon",children:[]},{value:"Where does Rust come in?",id:"where-does-rust-come-in",children:[]},{value:"Setting up your project",id:"setting-up-your-project",children:[]},{value:"Using the addon in Node.js",id:"using-the-addon-in-nodejs",children:[]},{value:"A deep dive into N-API",id:"a-deep-dive-into-n-api",children:[]},{value:"Working with promises and libuv thread pool",id:"working-with-promises-and-libuv-thread-pool",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],d={toc:u};function c(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Available Methods"),(0,i.kt)("li",{parentName:"ol"},"Native Addons"),(0,i.kt)("li",{parentName:"ol"},"Setting Of Project"),(0,i.kt)("li",{parentName:"ol"},"A deep dive in Napi"),(0,i.kt)("li",{parentName:"ol"},"Conclusion")),(0,i.kt)("h3",{id:"this-article-was-published-at-log-rocket"},"This article was published at ",(0,i.kt)("a",{parentName:"h3",href:"https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/"},"Log Rocket")),(0,i.kt)("p",null,"Node.js is a very popular JavaScript runtime for writing backend applications. Its flexibility and nonblocking nature have made it the premier choice for API consumption."),(0,i.kt)("p",null,"Since it is a scripting language, JavaScript can be pretty slow. But thanks to V8 optimization, it is fast enough for practical applications. That said, Node.js is not good for heavy lifting; since it\u2019s single-threaded, it is dangerous to block the main thread for doing long calculations. That\u2019s where ",(0,i.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/"},"worker")," ",(0,i.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/"}),(0,i.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/"},"threads")," come in. Node.js has support for worker threads, so it can be used to perform long calculations."),(0,i.kt)("p",null,'As great as worker threads are, JavaScript is still slow. Moreover, worker thread are not available in all supported LTS versions of Node. Fortunately, we can use Rust to build a native add-on for Node.js. FFI is another alternative, but it\u2019s slower than the add-on approach. Rust is blazing fast and has fearless concurrency. Since Rust has a very small runtime (or "not runtime"), our binary size should also be pretty small.'),(0,i.kt)("h2",{id:"what-is-rust"},"What is Rust?"),(0,i.kt)("p",null,"Rust is a systems programming language by Mozilla. It can call the C library by default and includes first-class support for exporting functions to C."),(0,i.kt)("p",null,"Rust provides you with low-level control and high-level ergonomics. It gives you control of memory management without the hassle associated with these controls. It also delivers zero-cost abstraction, so you pay for only what you use."),(0,i.kt)("p",null,"Rust can be called in a Node.js context via various methods. I\u2019ve listed some of the most widely used below."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can use FFI from Node.js and Rust, but this is very slow"),(0,i.kt)("li",{parentName:"ul"},"You can use WebAssembly to create a ",(0,i.kt)("inlineCode",{parentName:"li"},"node_module"),", but all Node.js functionality is not available"),(0,i.kt)("li",{parentName:"ul"},"You can use native addons")),(0,i.kt)("h2",{id:"what-is-a-native-addon"},"What is a native addon?"),(0,i.kt)("p",null,"Node.js addons are shared objects written in C++ that are dynamically linked. You can load them into Node.js using the ",(0,i.kt)("inlineCode",{parentName:"p"},"require()")," function and use them as if they were ordinary Node.js modules. They primarily provide an interface between JavaScript running in Node.js and C/C++ libraries."),(0,i.kt)("p",null,"A native addon provides a simple interface to work with another binary by loading it in V8 runtime. It is very fast and safe for making calls across the languages. Currently, Node.js supports two types of addon methods: C++ addons and N-API C++/C addons."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Addons")),(0,i.kt)("p",null,"A C++ addon is an object that can be mounted by Node.js and used in the runtime. Since C++ is a compiled language, these addons are very fast. C++ has a wide array of production-ready libraries that can be used to expand the Node.js ecosystem. Many popular libraries use native addons to improve performance and code quality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"N-API")," ",(0,i.kt)("strong",{parentName:"p"},"C++/C Addons")),(0,i.kt)("p",null,"The main problem with C++ addons is that you need to compile them again with every change to underlying JavaScript runtime. It causes a problem with maintaining the addon. N-API tries to eliminate this, by introducing a standard ABI (Application Binary Interface). The C header file remains backward compatible. That means the addon compiled for a particular version of Node.js, can be used with any version greater than the version of Node.js it was compiled for. You would use this method to implement your addon."),(0,i.kt)("h2",{id:"where-does-rust-come-in"},"Where does Rust come in?"),(0,i.kt)("p",null,"Rust can mimic the behavior of a C library. In other words, it exports the function in a format the C can understand and use. Rust calls the C function to access and use APIs provided by the Node.js. These APIs provide methods for creating JavaScript strings, arrays, numbers, error, objects, functions, and more. But we need to tell Rust what these external functions, structs, pointers, etc. look like."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#[repr(C)]\nstruct MyRustStruct {\n    a: i32,\n}\nextern "C" fn rust_world_callback(target: *mut RustObject, a: i32) {\n    println!("Function is called from C world", a);\n    unsafe {\n        // Do something on rust struct\n        (*target).a = a;\n    }\n}\nextern {\n   fn register_callback(target: *mut MyRustStruct,\n                        cb: extern fn(*mut MyRustStruct, i32)) -> i32;\n   fn trigger_callback();\n}\n')),(0,i.kt)("p",null,"Rust lays down the structs in memory differently, so we need to tell it to use the style C uses. It would a pain to create these functions by hand, so we\u2019ll use a crate called ",(0,i.kt)("inlineCode",{parentName:"p"},"nodejs-sys")," that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"bindgen")," to create a nice definition for N-API."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"b``indgen")," automatically generates Rust FFI bindings to C and C++ libraries."),(0,i.kt)("p",null,"Note: There will a lot of unsafe code ahead, mostly external function calls."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://dev-to-uploads.s3.amazonaws.com/i/4rgbnohg8ly3hb5g1vac.gif",alt:"Joker"})),(0,i.kt)("h2",{id:"setting-up-your-project"},"Setting up your project"),(0,i.kt)("p",null,"For this tutorial, you must have ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/"},"Node.js")," and ",(0,i.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"Rust")," installed on your system, with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/cargo/"},"Cargo")," and ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/"},"NPM"),". I would suggest using ",(0,i.kt)("a",{parentName:"p",href:"https://rustup.rs/"},"Rustup")," to install Rust and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nvm-sh/nvm"},"nvm")," for Node.js."),(0,i.kt)("p",null,"Create a directory named ",(0,i.kt)("inlineCode",{parentName:"p"},"rust-addon")," and initialize a new npm project by running ",(0,i.kt)("inlineCode",{parentName:"p"},"npm init"),". Next, init a cargo project called ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo init --lib"),". Your project directory should look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Configuring Rust to compile to the addon")),(0,i.kt)("p",null,"We need Rust to compile to a dynamic C library or object. Configure cargo to compile to the ",(0,i.kt)("inlineCode",{parentName:"p"},".so")," file on Linux, ",(0,i.kt)("inlineCode",{parentName:"p"},".dylib")," on OS X, and ",(0,i.kt)("inlineCode",{parentName:"p"},".dll")," on Windows. Rust can produce many different types of libraries using Rustc flags or Cargo."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "rust-addon"\nversion = "0.1.0"\nauthors = ["Anshul Goyal <anshulgoel151999@gmail.com>"]\nedition = "2018"\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[lib]\ncrate-type=["cdylib"]\n\n[dependencies]\nnodejs-sys = "0.2.0"\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"lib")," key provides options to configure Rustc. The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," key gives the library name to the shared object in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"lib{name}"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," provides the type of library it should be compiled to \u2014 e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"cdylib"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"rlib"),", etc. ",(0,i.kt)("inlineCode",{parentName:"p"},"cdylib")," creates a dynamically linked C library. This shared object behaves like a C library."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Starting with")," ",(0,i.kt)("strong",{parentName:"p"},"N-API")),(0,i.kt)("p",null,"Let\u2019s create our N-API library. We need to add a dependency. ",(0,i.kt)("inlineCode",{parentName:"p"},"nodejs-sys")," provides us with the binding required for ",(0,i.kt)("inlineCode",{parentName:"p"},"napi-header")," files. ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_register_module_v1")," is the entry point for the addon. ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/api/n-api.html#n_api_module_registration"},"N"),(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/api/n-api.html#n_api_module_registration"},"-"),(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/api/n-api.html#n_api_module_registration"},"API documentation")," recommends ",(0,i.kt)("inlineCode",{parentName:"p"},"N-API``_MODULE_INIT")," macro for module registration which compiles to ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_register_module_v1")," function."),(0,i.kt)("p",null,"Node.js calls this function and provides it with an opaque pointer called ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_env"),", which refers to the configuration of the module in JavaScript runtime, and ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_value"),". The latter is another opaque pointer that represents a JavaScript value, which, in reality is an object known as an export. These exports are the same as those the ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," function provides to the Node.js modules in JavaScript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use nodejs_sys::{napi_create_string_utf8, napi_env, napi_set_named_property, napi_value};\nuse std::ffi::CString;\n#[no_mangle]\npub unsafe extern "C" fn napi_register_module_v1(\n    env: napi_env,\n    exports: napi_value,\n) -> nodejs_sys::napi_value {\n// creating a C string\n    let key = CString::new("hello").expect("CString::new failed");\n// creating a memory location where the pointer to napi_value will be saved\n    let mut local: napi_value = std::mem::zeroed();\n// creating a C string\n    let value = CString::new("world!").expect("CString::new failed");\n// creating napi_value for the string\n    napi_create_string_utf8(env, value.as_ptr(), 6, &mut local);\n// setting the string on the exports object\n    napi_set_named_property(env, exports, key.as_ptr(), local);\n// returning the object\n    exports\n}\n')),(0,i.kt)("p",null,"Rust represents owned strings with the ",(0,i.kt)("inlineCode",{parentName:"p"},"S``tring")," type and borrowed slices of strings with the ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," primitive. Both are always in UTF-8 encoding and may contain null bytes in the middle. If you look at the bytes that make up the string, there may be a ",(0,i.kt)("inlineCode",{parentName:"p"},"\\0")," among them. Both ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," store their length explicitly; there are no null terminators at the end of strings like C strings."),(0,i.kt)("p",null,"Rust strings are very different from the ones in C, so we need to change our Rust strings to C strings before we can use then with N-API functions. Since exports is an object represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"exports"),", we can add functions, strings, arrays, or any other JavaScript objects as key-value pairs."),(0,i.kt)("p",null,"To add a key to a JavaScript object, you can use a method provided by the N-API ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_set_named_property"),". This function takes the object to which we want to add a property; a pointer to a string that will be used as the key for our property; the pointer to the JavaScript value, which can be a string, array, etc.; and ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_env"),", which acts an anchor between Rust and Node.js."),(0,i.kt)("p",null,"You can use N-API functions to create any JavaScript value. For example, we used ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_string_utf8")," here to create a string. We passed in the environment a pointer to the string, the length of string, and a pointer to an empty memory location where it can write the pointer to the newly created value. All this code is unsafe because it includes many calls to external functions where the compiler cannot provide Rust guarantees. In the end, we returned the module that was provided to us by setting a property on it with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"world!"),"."),(0,i.kt)("p",null,"It\u2019s important to understand that ",(0,i.kt)("inlineCode",{parentName:"p"},"nodejs-sys")," just provides the required definitions for the function you\u2019re using, not their implementation. N-API implementation is included with Node.js and you call it from your Rust code."),(0,i.kt)("h2",{id:"using-the-addon-in-nodejs"},"Using the addon in Node.js"),(0,i.kt)("p",null,"The next step is to add a linking configuration for different operating systems, then you can compile it."),(0,i.kt)("p",null,"Create a ",(0,i.kt)("inlineCode",{parentName:"p"},"build.rs")," file to add a few configuration flags for linking the N-API files on different operating systems."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'fn main() {\n    println!("cargo:rustc-cdylib-link-arg=-undefined");\n    if cfg!(target_os = "macos") {\n        println!("cargo:rustc-cdylib-link-arg=dynamic_lookup");\n    }\n}\n')),(0,i.kt)("p",null,"Your directory should look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 build.rs\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 index.node\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs\n")),(0,i.kt)("p",null,"Now you need to compile your Rust addon. You can do so pretty easily using the simple command ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo build --release"),". This will take some time on the first run."),(0,i.kt)("p",null,"After your module is compiled, create a copy of this binary from ",(0,i.kt)("inlineCode",{parentName:"p"},"./target/release/libnative.so")," to your root directory and rename it as ",(0,i.kt)("inlineCode",{parentName:"p"},"index.node"),". The binary created by the cargo may have a different extension or name, depending on your crate setting and operating system."),(0,i.kt)("p",null,"Now you can require the file in Node.js and use it. You can also use it in a script. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let addon=require('./index.node');\nconsole.log(addon.hello);\n")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://dev-to-uploads.s3.amazonaws.com/i/ozbxwwmm6680oz97v5ds.png",alt:"Example"})),(0,i.kt)("p",null,"Next, we\u2019ll move on to creating functions, arrays, and promises and using ",(0,i.kt)("inlineCode",{parentName:"p"},"libuv thread-pool")," to perform heavy tasks without blocking the main thread."),(0,i.kt)("h2",{id:"a-deep-dive-into-n-api"},"A deep dive into N-API"),(0,i.kt)("p",null,"Now you know how to implement common patterns using N-API and Rust. A very common pattern is the export function, which can be called by the user of the library or Node module. Let\u2019s start by creating a function."),(0,i.kt)("p",null,"You should use ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_function")," to create your functions so that you can use them from Node.js. You can add these functions as a property to exports to use from Node.js."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Creating a function")),(0,i.kt)("p",null,"JavaScript functions are also represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_value")," pointer. A N-API function is pretty easy to create and use."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use nodejs_sys::{\n    napi_callback_info, napi_create_function, napi_create_string_utf8, napi_env,\n    napi_set_named_property, napi_value,\n};\nuse std::ffi::CString;\npub unsafe extern "C" fn say_hello(env: napi_env, _info: napi_callback_info) -> napi_value {\n// creating  a javastring string\n    let mut local: napi_value = std::mem::zeroed();\n    let p = CString::new("Hello from rust").expect("CString::new    failed");\n    napi_create_string_utf8(env, p.as_ptr(), 13, &mut local);\n// returning the javascript string\n    local\n}\n#[no_mangle]\npub unsafe extern "C" fn napi_register_module_v1(\n    env: napi_env,\n    exports: napi_value,\n) -> nodejs_sys::napi_value {\n// creating a C String\n    let p = CString::new("myFunc").expect("CString::new failed");\n// creating a location where pointer to napi_value be written\n    let mut local: napi_value = std::mem::zeroed();\n    napi_create_function(\n        env,\n// pointer to function name\n        p.as_ptr(),\n// length of function name\n        5,\n// rust function\n        Some(say_hello),\n// context which can be accessed by the rust function\n        std::ptr::null_mut(),\n// output napi_value\n        &mut local,\n    );\n// set function as property\n    napi_set_named_property(env, exports, p.as_ptr(), local);\n// returning exports\n    exports\n}\n')),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://dev-to-uploads.s3.amazonaws.com/i/cfzmn20r0doiuhdgqaq3.png",alt:"Example"})),(0,i.kt)("p",null,"In the above example, we created a function in Rust named ",(0,i.kt)("inlineCode",{parentName:"p"},"say_hello"),", which is executed when the JavaScript calls the function. We created a function using ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_function"),", which takes the following arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"napi_env")," value of the environment"),(0,i.kt)("li",{parentName:"ul"},"A string for the function name which that be given to the JavaScript function"),(0,i.kt)("li",{parentName:"ul"},"The length of the function name string"),(0,i.kt)("li",{parentName:"ul"},"The function that is executed when the JavaScript calls the newly created function"),(0,i.kt)("li",{parentName:"ul"},"Context data that can be passed by the user later and accessed from the Rust function"),(0,i.kt)("li",{parentName:"ul"},"An empty memory address where the pointer to the JavaScript function can be saved"),(0,i.kt)("li",{parentName:"ul"},"When you create this function, add it as a property to your ",(0,i.kt)("inlineCode",{parentName:"li"},"exports")," object so that you can use it from JavaScript")),(0,i.kt)("p",null,"The function on the Rust side must have the same signature as shown in the example. We\u2019ll discuss next how to access arguments inside a function using ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_callback_info"),". We can access this from a function and other arguments as well."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Accessing")," ",(0,i.kt)("strong",{parentName:"p"},"arguments")),(0,i.kt)("p",null,"Function arguments are very important. N-API provides a method to access these arguments. ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_callback_info")," provides the pointer with detailed information about the function in the JavaScript side of the code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use nodejs_sys::{\n    napi_callback_info, napi_create_double, napi_create_function, napi_env, napi_get_cb_info,\n    napi_get_value_double, napi_set_named_property, napi_value,\n};\nuse std::ffi::CString;\n\npub unsafe extern "C" fn add(env: napi_env, info: napi_callback_info) -> napi_value {\n// creating a buffer where napi_value of argument be written\n    let mut buffer: [napi_value; 2] = std::mem::MaybeUninit::zeroed().assume_init();\n// max number of arguments\n    let mut argc = 2 as usize;\n// getting arguments and value of this\n    napi_get_cb_info(\n        env,\n        info,\n        &mut argc,\n        buffer.as_mut_ptr(),\n        std::ptr::null_mut(),\n        std::ptr::null_mut(),\n    );\n// converting napi to f64\n    let mut x = 0 as f64;\n    let mut y = 0 as f64;\n    napi_get_value_double(env, buffer[0], &mut x);\n    napi_get_value_double(env, buffer[1], &mut y);\n// creating the return value\n    let mut local: napi_value = std::mem::zeroed();\n    napi_create_double(env, x + y, &mut local);\n// returning the result\n    local\n}\n\n#[no_mangle]\npub unsafe extern "C" fn napi_register_module_v1(\n    env: napi_env,\n    exports: napi_value,\n) -> nodejs_sys::napi_value {\n// creating a function name\n    let p = CString::new("myFunc").expect("CString::new failed");\n    let mut local: napi_value = std::mem::zeroed();\n// creating the function\n    napi_create_function(\n        env,\n        p.as_ptr(),\n        5,\n        Some(add),\n        std::ptr::null_mut(),\n        &mut local,\n    );\n// setting function as property\n    napi_set_named_property(env, exports, p.as_ptr(), local);\n// returning exports\n    exports\n}\n')),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://dev-to-uploads.s3.amazonaws.com/i/u3r2j1xw1oh43jr8gygv.png",alt:"Example"})),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_get_cb_info")," to get the arguments. The following arguments must be provided:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"napi_env")),(0,i.kt)("li",{parentName:"ul"},"The info pointer"),(0,i.kt)("li",{parentName:"ul"},"The number of expected arguments"),(0,i.kt)("li",{parentName:"ul"},"A buffer where arguments can be written as ",(0,i.kt)("inlineCode",{parentName:"li"},"napi_value")),(0,i.kt)("li",{parentName:"ul"},"A memory location to store metadata the user provided when JavaScript function was created"),(0,i.kt)("li",{parentName:"ul"},"A memory location where this value pointer can be written")),(0,i.kt)("p",null,"We need to create an array with memory locations where C can write a pointer to arguments and we can pass this pointer buffer to N-API function. We also get ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),", but we aren\u2019t using it in this example."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Working with strings arguments")),(0,i.kt)("p",null,"Most of the time, you need to work with strings in JavaScript. Both creating and getting the value of a string are pretty straightforward. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_get_value_string_utf8")," and call this function twice: the first time to get length and second time to get the value of the string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use nodejs_sys::{\n    napi_callback_info, napi_create_function, napi_env, napi_get_cb_info, napi_get_undefined,\n    napi_get_value_string_utf8, napi_set_named_property, napi_value,\n};\n\nuse std::ffi::CString;\n\npub unsafe extern "C" fn print(env: napi_env, info: napi_callback_info) -> napi_value {\n// creating a buffer of arguments\n    let mut buffer: [napi_value; 1] = std::mem::MaybeUninit::zeroed().assume_init();\n    let mut argc = 1 as usize;\n// getting arguments\n    napi_get_cb_info(\n        env,\n        info,\n        &mut argc,\n        buffer.as_mut_ptr(),\n        std::ptr::null_mut(),\n        std::ptr::null_mut(),\n    );\n    let mut len = 0;\n// getting length by passing null buffer\n    napi_get_value_string_utf8(env, buffer[0], std::ptr::null_mut(), 0, &mut len);\n    let size = len as usize;\n// creating a buffer where string can be placed\n    let mut ve: Vec<u8> = Vec::with_capacity(size + 1);\n    let raw = ve.as_mut_ptr();\n// telling rust not manage the vector\n    std::mem::forget(ve);\n    let mut cap = 0;\n// getting the string value from napi_value\n    let _s = napi_get_value_string_utf8(env, buffer[0], raw as *mut i8, size + 1, &mut cap);\n    let s = String::from_raw_parts(raw, cap as usize, size);\n// printing the string\n    println!("{}", s);\n// creating an undefined\n    let mut und: napi_value = std::mem::zeroed();\n    napi_get_undefined(env, &mut und);\n// returning undefined\n    und\n}\n\n#[no_mangle]\npub unsafe extern "C" fn napi_register_module_v1(\n    env: napi_env,\n    exports: napi_value,\n) -> nodejs_sys::napi_value {\n    let p = CString::new("myFunc").expect("CString::new failed");\n    let mut local: napi_value = std::mem::zeroed();\n    napi_create_function(\n        env,\n        p.as_ptr(),\n        5,\n        Some(print),\n        std::ptr::null_mut(),\n        &mut local,\n    );\n    napi_set_named_property(env, exports, p.as_ptr(), local);\n    exports\n}\n')),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://dev-to-uploads.s3.amazonaws.com/i/zbk15csxak95qvnd2tcg.png",alt:"Example"})),(0,i.kt)("p",null,"You\u2019ll need to pass a few arguments to ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_string_utf8")," to create a string. If a null pointer is passed as buffer, the length of the string is given. The following arguments are required:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"napi_env")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"napi_value")," pointer to the string in ",(0,i.kt)("inlineCode",{parentName:"li"},"javascript side")),(0,i.kt)("li",{parentName:"ul"},"The buffer where the string is to be written if null gives the length of the string"),(0,i.kt)("li",{parentName:"ul"},"The length of the buffer"),(0,i.kt)("li",{parentName:"ul"},"Bytes written to the buffer")),(0,i.kt)("h2",{id:"working-with-promises-and-libuv-thread-pool"},"Working with promises and libuv thread pool"),(0,i.kt)("p",null,"It\u2019s not a good idea to block the main thread of Node.js for doing calculations. You can use libuv threads to do the heavy lifting."),(0,i.kt)("p",null,"First, create a promise. The promise will reject or resolve based on the success of your work. For this, you\u2019ll need to create three functions. The first one is called from the JavaScript world and the control would be passed to the second function, which runs on libuv thread and has no access to JavaScript. The third function, which does have access to the JavaScript side, is called after the second finishes. You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_async_work")," method for the libuv thread."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Creating a promise")),(0,i.kt)("p",null,"To create a promise, simply use ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_promise"),". This will provide a pointer, ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_deferred"),", which can then resolve or reject a promise using the following functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"napi_resolve_deferred")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"napi_reject_deferred"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Error handling")),(0,i.kt)("p",null,"You can create and throw an error from the Rust code using ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_error")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_throw_error"),". Every N-API function returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_status"),", which should be checked."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Real code")),(0,i.kt)("p",null,"The following example shows how to schedule async work."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    use nodejs_sys::{\n        napi_async_work, napi_callback_info, napi_create_async_work, napi_create_error,\n        napi_create_function, napi_create_int64, napi_create_promise, napi_create_string_utf8,\n        napi_deferred, napi_delete_async_work, napi_env, napi_get_cb_info, napi_get_value_int64,\n        napi_queue_async_work, napi_reject_deferred, napi_resolve_deferred, napi_set_named_property,\n        napi_status, napi_value,\n    };\n    use std::ffi::c_void;\n    use std::ffi::CString;\n\n    #[derive(Debug, Clone)]\n    struct Data {\n        deferred: napi_deferred,\n        work: napi_async_work,\n        val: u64,\n        result: Option<Result<u64, String>>,\n    }\n\n    pub unsafe extern "C" fn feb(env: napi_env, info: napi_callback_info) -> napi_value {\n        let mut buffer: Vec<napi_value> = Vec::with_capacity(1);\n        let p = buffer.as_mut_ptr();\n        let mut argc = 1 as usize;\n        std::mem::forget(buffer);\n        napi_get_cb_info(\n            env,\n            info,\n            &mut argc,\n            p,\n            std::ptr::null_mut(),\n            std::ptr::null_mut(),\n        );\n        let mut start = 0;\n        napi_get_value_int64(env, *p, &mut start);\n        let mut promise: napi_value = std::mem::zeroed();\n        let mut deferred: napi_deferred = std::mem::zeroed();\n        let mut work_name: napi_value = std::mem::zeroed();\n        let mut work: napi_async_work = std::mem::zeroed();\n        let async_name = CString::new("async fibonaci").expect("Error creating string");\n        napi_create_string_utf8(env, async_name.as_ptr(), 13, &mut work_name);\n        napi_create_promise(env, &mut deferred, &mut promise);\n        let v = Data {\n            deferred,\n            work,\n            val: start as u64,\n            result: None,\n        };\n        let data = Box::new(v);\n        let raw = Box::into_raw(data);\n        napi_create_async_work(\n            env,\n            std::ptr::null_mut(),\n            work_name,\n            Some(perform),\n            Some(complete),\n            std::mem::transmute(raw),\n            &mut work,\n        );\n        napi_queue_async_work(env, work);\n        (*raw).work = work;\n        promise\n    }\n\n    pub unsafe extern "C" fn perform(_env: napi_env, data: *mut c_void) {\n        let mut t: Box<Data> = Box::from_raw(std::mem::transmute(data));\n        let mut last = 1;\n        let mut second_last = 0;\n        for _ in 2..t.val {\n            let temp = last;\n            last = last + second_last;\n            second_last = temp;\n        }\n        t.result = Some(Ok(last));\n        Box::into_raw(task);\n    }\n\n    pub unsafe extern "C" fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {\n        let t: Box<Data> = Box::from_raw(std::mem::transmute(data));\n        let v = match t.result {\n            Some(d) => match d {\n                Ok(result) => result,\n                Err(_) => {\n                    let mut js_error: napi_value = std::mem::zeroed();\n                    napi_create_error(\n                        env,\n                        std::ptr::null_mut(),\n                        std::ptr::null_mut(),\n                        &mut js_error,\n                    );\n                    napi_reject_deferred(env, t.deferred, js_error);\n                    napi_delete_async_work(env, t.work);\n                    return;\n                }\n            },\n            None => {\n                let mut js_error: napi_value = std::mem::zeroed();\n                napi_create_error(\n                    env,\n                    std::ptr::null_mut(),\n                    std::ptr::null_mut(),\n                    &mut js_error,\n                );\n                napi_reject_deferred(env, t.deferred, js_error);\n                napi_delete_async_work(env, t.work);\n                return;\n            }\n        };\n        let mut obj: napi_value = std::mem::zeroed();\n        napi_create_int64(env, v as i64, &mut obj);\n        napi_resolve_deferred(env, t.deferred, obj);\n\n        napi_delete_async_work(env, t.work);\n    }\n\n    #[no_mangle]\n    pub unsafe extern "C" fn napi_register_module_v1(\n        env: napi_env,\n        exports: napi_value,\n    ) -> nodejs_sys::napi_value {\n        let p = CString::new("myFunc").expect("CString::new failed");\n        let mut local: napi_value = std::mem::zeroed();\n        napi_create_function(\n            env,\n            p.as_ptr(),\n            5,\n            Some(feb),\n            std::ptr::null_mut(),\n            &mut local,\n        );\n        napi_set_named_property(env, exports, p.as_ptr(), local);\n        exports\n    }\n')),(0,i.kt)("p",null,"We created a struct to store a pointer to our ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_async_work")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_deferred")," as well as our output. Initially, the output is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". Then we created a promise, which provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"deferred")," that we save in our data. This data is available to us in all of our functions. Next, we converted our data into raw data and pass it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_async_work")," function with other callbacks. We returned the promise we created, executed ",(0,i.kt)("inlineCode",{parentName:"p"},"perform"),", and converted our data back to struct. Once ",(0,i.kt)("inlineCode",{parentName:"p"},"perform")," is completed on libuv thread, ",(0,i.kt)("inlineCode",{parentName:"p"},"complete")," is called from the main thread, along with the status of the previous operation and our data. Now we can reject or resolve our work and delete work from the queue."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Lets walk through the code")),(0,i.kt)("p",null,"Create a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"feb"),", which will be exported to JavaScript. This function will return a promise and schedule work for the libuv thread pool. You can achieve this by creating a promise, using ",(0,i.kt)("inlineCode",{parentName:"p"},"napi_create_async_work"),", and passing two functions to it. One is executed on the libuv thread and the other on the main thread. Since you can only execute JavaScript from the main thread, you must resolve or reject a promise only from the main thread. The code includes a large number of unsafe functions."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"feb")," function")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'pub unsafe extern "C" fn feb(env: napi_env, info: napi_callback_info) -> napi_value {\n    let mut buffer: Vec<napi_value> = Vec::with_capacity(1);\n    let p = buffer.as_mut_ptr();\n    let mut argc = 1 as usize;\n    std::mem::forget(buffer);\n// getting arguments for the function\n    napi_get_cb_info(\n        env,\n        info,\n        &mut argc,\n        p,\n        std::ptr::null_mut(),\n        std::ptr::null_mut(),\n    );\n    let mut start = 0;\n// converting the napi_value to u64 number\n    napi_get_value_int64(env, *p, &mut start);\n// promise which would be returned\n    let mut promise: napi_value = std::mem::zeroed();\n// a pointer to promise to resolve is or reject it\n    let mut deferred: napi_deferred = std::mem::zeroed();\n// a pointer to our async work name used for debugging\n    let mut work_name: napi_value = std::mem::zeroed();\n// pointer to async work\n    let mut work: napi_async_work = std::mem::zeroed();\n    let async_name = CString::new("async fibonaci").expect("Error creating string");\n// creating a string for name\n    napi_create_string_utf8(env, async_name.as_ptr(), 13, &mut work_name);\n// creating a promise\n    napi_create_promise(env, &mut deferred, &mut promise);\n    let v = Data {\n        deferred,\n        work,\n        val: start as u64,\n        result: None,\n    };\n// creating a context which can be saved to share state between our functions\n    let data = Box::new(v);\n// converting it to raw pointer\n    let raw = Box::into_raw(data);\n// creating the work\n    napi_create_async_work(\n        env,\n        std::ptr::null_mut(),\n        work_name,\n        Some(perform),\n        Some(complete),\n        std::mem::transmute(raw),\n        &mut work,\n    );\n// queuing to execute the work\n    napi_queue_async_work(env, work);\n// setting pointer to work that can be used later\n    (*raw).work = work;\n// retuning the pormise\n    promise\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"perform")," function")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'pub unsafe extern "C" fn perform(_env: napi_env, data: *mut c_void) {\n// getting the shared data and converting the in box\n    let mut t: Box<Data> = Box::from_raw(std::mem::transmute(data));\n    let mut last = 1;\n    let mut second_last = 0;\n    for _ in 2..t.val {\n        let temp = last;\n        last = last + second_last;\n        second_last = temp;\n    }\n// setting the result on shared context\n    t.result = Some(Ok(last));\n// telling the rust to not to drop the context data\n    Box::into_raw(t);\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"complete")," Function")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'pub unsafe extern "C" fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {\n// getting the shared context\n    let t: Box<Data> = Box::from_raw(std::mem::transmute(data));\n    let v = match task.result {\n        Some(d) => match d {\n            Ok(result) => result,\n            Err(_) => {\n// if there is error just throw an error\n// creating error\n                let mut js_error: napi_value = std::mem::zeroed();\n                napi_create_error(\n                    env,\n                    std::ptr::null_mut(),\n                    std::ptr::null_mut(),\n                    &mut js_error,\n                );\n// rejecting the promise with error\n                napi_reject_deferred(env, task.deferred, js_error);\n// deleting the task from the queue\n                napi_delete_async_work(env, task.work);\n                return;\n            }\n        },\n        None => {\n// if no result is found reject with error\n// creating an error\n            let mut js_error: napi_value = std::mem::zeroed();\n            napi_create_error(\n                env,\n                std::ptr::null_mut(),\n                std::ptr::null_mut(),\n                &mut js_error,\n            );\n// rejecting promise with error\n            napi_reject_deferred(env, task.deferred, js_error);\n// deleting the task from queue\n            napi_delete_async_work(env, task.work);\n            return;\n        }\n    };\n// creating the number\n    let mut obj: napi_value = std::mem::zeroed();\n    napi_create_int64(env, v as i64, &mut obj);\n// resolving the promise with result\n    napi_resolve_deferred(env, t.deferred, obj);\n// deleting the work\n    napi_delete_async_work(env, t.work);\n}\n')),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"This is just the tip of the iceberg when it comes to what you can do with N-API. We went over a few patterns and covered the basics, such as how to export function, create oft-used JavaScript types such as strings, numbers, arrays, objects, etc., get the context of a function (i.e., get the arguments and ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," in a function), etc."),(0,i.kt)("p",null,"We also examined an in-depth example of how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"libuv")," threads and create an ",(0,i.kt)("inlineCode",{parentName:"p"},"async_work")," to perform heavy calculations in the background. Finally, we created and used JavaScript's promises and learned how to do error handling in N-APIs."),(0,i.kt)("p",null,"There are many libraries available if you don\u2019t want to write all the code by hand. These provide nice abstractions, but the downside is that they don't support all features."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/neon-bindings/neon"},"noen")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/infinyon/node-bindgen"},"node-bindgen")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Brooooooklyn/napi-rs"},"napi-rs"))))}c.isMDXComponent=!0}}]);