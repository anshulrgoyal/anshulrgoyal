(self.webpackChunkanshulrgoyal=self.webpackChunkanshulrgoyal||[]).push([[724],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||a;return n?i.createElement(m,r(r({ref:t},p),{},{components:n})):i.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var u=2;u<a;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8252:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return p},default:function(){return d}});var i=n(2122),o=n(9756),a=(n(7294),n(3905)),r=["components"],l={slug:"deno-plugin",title:"How to create a Deno plugin in Rust",author:"Anshul Goyal",author_url:"https://github.com/anshulrgoyal",author_image_url:"/img/anshul.jpg",tags:["rust","deno"],image:"https://blog.logrocket.com/wp-content/uploads/2021/06/deno-rust-plugin.png"},s=void 0,u={permalink:"/anshulrgoyal/blog/deno-plugin",source:"@site/blog/2021-06-24-deno.md",title:"How to create a Deno plugin in Rust",description:"Deno is a new JavaScript runtime built with Rust and V8 that enables you to run JavaScript outside the browser. Deno is more secure than Node.js because it limits network and file system access by default.",date:"2021-06-24T00:00:00.000Z",formattedDate:"June 24, 2021",tags:[{label:"rust",permalink:"/anshulrgoyal/blog/tags/rust"},{label:"deno",permalink:"/anshulrgoyal/blog/tags/deno"}],readingTime:6.325,truncated:!0,nextItem:{title:"An intro to macros in rust",permalink:"/anshulrgoyal/blog/macro-rust"}},p=[{value:"Why write Deno plugins in Rust?",id:"why-write-deno-plugins-in-rust",children:[]},{value:"Deno plugin project structure",id:"deno-plugin-project-structure",children:[]},{value:"Building a Rust project",id:"building-a-rust-project",children:[]},{value:"Adding Rust code",id:"adding-rust-code",children:[]},{value:"Creating the optimizer function",id:"creating-the-optimizer-function",children:[]},{value:"Loading a Rust plugin in Deno",id:"loading-a-rust-plugin-in-deno",children:[]},{value:"Writing async plugins",id:"writing-async-plugins",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],c={toc:p};function d(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Deno is a new JavaScript runtime built with Rust and V8 that enables you to run JavaScript outside the browser. ",(0,a.kt)("a",{parentName:"p",href:"https://blog.logrocket.com/what-is-deno/"},"Deno is more secure than Node.js")," because it limits network and file system access by default. "),(0,a.kt)("p",null,"One of the cool things about Deno is that it enables you to write and use plugins written in Rust within Deno code. This works thanks to plugins, which can also be written in Rust."),(0,a.kt)("p",null,"In this tutorial, we\u2019ll show you how to create Deno plugins in Rust. We\u2019ll cover the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:uid=744656682274102420634231&h2=Why-write-Deno-plugins-in-Rust"},"Why write Deno plugins in Rust?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:uid=212989478249355405870882&h2=Deno-plugin-project-structure"},"Deno plugin project structure")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:h2=Building-a-Rust-project"},"Building a Rust project")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:uid=717384026671171805848518&h2=Adding-Rust-code"},"Adding Rust code")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:h2=Creating-the-optimizer-functio"},"Creating the optimizer function")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:h2=Loading-a-Rust-plugin-in-Deno"},"Loading a Rust plugin in Deno")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://paper.dropbox.com/doc/How-to-create-a-Deno-plugin-in-Rust--BL3wF7W8gXJh4XBumWI1K_9xAg-UDzW8fsLUigxSvaZJMh7r#:h2=Writing-async-plugins"},"Writing async plugins"))),(0,a.kt)("h2",{id:"why-write-deno-plugins-in-rust"},"Why write Deno plugins in Rust?"),(0,a.kt)("p",null,"Plugins in Deno generally provide better performance and provide access to a wider range of tools. "),(0,a.kt)("p",null,"Due to their performant nature, plugins are often used to perform calculations for heavy tasks such as image processing. Plugins also give you access to a variety of libraries written in other languages, including high-quality Rust crates."),(0,a.kt)("h2",{id:"deno-plugin-project-structure"},"Deno plugin project structure"),(0,a.kt)("p",null,"The plugin project structure is the same as any Deno module. For project structure, you can use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/BrunnerLivio/deno-module-starter"},"this boilerplate"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git clone https://github.com/anshulrgoyal/deno-rust-starter.git my_module\n")),(0,a.kt)("p",null,"First, build the Rust boilerplate for the plugin:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cd my_module/native\ncargo build\n")),(0,a.kt)("p",null,"Next, run a test to verify that Deno is picking up the correct library:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cd my_module/native\ndeno test --unstable --allow-plugin\n")),(0,a.kt)("p",null,"The boilerplate includes a Rust project in the ",(0,a.kt)("inlineCode",{parentName:"p"},"native")," directory and a Deno module in the root."),(0,a.kt)("h2",{id:"building-a-rust-project"},"Building a Rust project"),(0,a.kt)("p",null,"The Rust project compiles a dynamic library that is loaded by the Deno runtime. The file type and name of the library depends on the operating system. The Rust project may compile to a ",(0,a.kt)("inlineCode",{parentName:"p"},"so")," file \u2014  ",(0,a.kt)("inlineCode",{parentName:"p"},"dylib")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"dll")," \u2014 and the name of the compiled file may also be different. The boilerplate can handle three major platforms: Linux, macOS, and Windows."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'[package]\nname = "native"\nversion = "0.1.0"\nauthors = ["anshul <anshulgoel151999@gmail.com>"]\nedition = "2018"\n\n[lib]\nname = "native"\ncrate-type = ["cdylib"]\n\n[dependencies]\ndeno_core = "0.75.0"\n\n\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 deps.ts\n\u251c\u2500\u2500 mod.ts\n\u251c\u2500\u2500 mod_test.ts\n\u251c\u2500\u2500 native\n\u2502   \u251c\u2500\u2500 Cargo.lock\n\u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u251c\u2500\u2500 src\n\u2502       \u2514\u2500\u2500 lib.rs\n\u251c\u2500\u2500 test.ts\n\u251c\u2500\u2500 test_deps.ts\n\u2514\u2500\u2500 tsconfig.json\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"mod.ts")," file is the main file imported by another application using your module."),(0,a.kt)("h2",{id:"adding-rust-code"},"Adding Rust code"),(0,a.kt)("p",null,"For this tutorial, we\u2019ll show you how to build a PNG optimizer using an ",(0,a.kt)("inlineCode",{parentName:"p"},"oxipng")," crate. Every Deno plugin must export the ",(0,a.kt)("inlineCode",{parentName:"p"},"deno_plugin_init")," function and register all the methods that the plugin exports."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"#[no_mangle]")," attribute tells the compiler not to change the name of the function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'#[no_mangle]\npub fn deno_plugin_init(interface: &mut dyn Interface) {\n // register the function. Pass name and function to register method\n    interface.register_op("hello_world",hello_world);\n}\n')),(0,a.kt)("h2",{id:"creating-the-optimizer-function"},"Creating the optimizer function"),(0,a.kt)("p",null,"Each exported function has the same signature. Deno plugins can only export functions. These functions can be sync or async, depending on the return type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"fn optimise(_interface: &mut dyn Interface,\n    zero_copy: &mut [ZeroCopyBuf],\n) -> Op {\n    // get first argument\n    let first=zero_copy.first().unwrap();\n    let opts: oxipng::Options = Default::default();\n    // convert vector\n    let result = oxipng::optimize_from_memory(&first.to_vec(), &opts).unwrap();\n    // move to heap so that deno can use it\n    Op::Sync(Box::from(result))\n}\n")),(0,a.kt)("p",null,"The second argument of the function contains an array of buffers. Each buffer in the array represents the argument passed to the exported function when called. These buffers are serialized to strings or other data types based on requirements. "),(0,a.kt)("p",null,"The above code takes the first element of ",(0,a.kt)("inlineCode",{parentName:"p"},"zero_copy")," and passes it to ",(0,a.kt)("inlineCode",{parentName:"p"},"optimize_from_memory"),". The first element of the array is the file passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"optimize")," function when called from the Deno code. The file is passed as bytes. The function processes the file and returns the result as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Box"),". The return type is ",(0,a.kt)("inlineCode",{parentName:"p"},"Op")," enum with two variants ",(0,a.kt)("inlineCode",{parentName:"p"},"sync")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"async"),"."),(0,a.kt)("p",null,"Build the code using the ",(0,a.kt)("inlineCode",{parentName:"p"},"cargo build")," command. Now this plugin can be used in Deno."),(0,a.kt)("h2",{id:"loading-a-rust-plugin-in-deno"},"Loading a Rust plugin in Deno"),(0,a.kt)("p",null,"Now that the plugin is compiled, let\u2019s load it using Deno. "),(0,a.kt)("p",null,"The plugin is still in development and is a part of unstable APIs, so the ",(0,a.kt)("inlineCode",{parentName:"p"},"--unstable")," flag is required, as is ",(0,a.kt)("inlineCode",{parentName:"p"},"--allow-plugin"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'let path = ""\n// check the type of OS to load correct file\nif (Deno.build.os === "linux") {\n// linux file emited by rust compiler\n  path = "./native/target/debug/libnative.so"\n} else if (Deno.build.os === "windows") {\n// windows file emited by rust compiler\n  path = "./native/target/debug/native.dll"\n} else if (Deno.build.os === "darwin") {\n// macos file emited by rust comipler\n  path = "./native/target/debug/libnative.dylib"\n}\n// load plugin from file system\nconst rid = Deno.openPlugin(path);\n// Get available methods on plugin\n//@ts-Expect-Error\nconst { optimise:optimise_native } = (Deno as any).core.ops();\n\nexport async function optimise(fileName: string): Promise<Uint8Array> {\n// reading a file\n  const file = await Deno.open(fileName);\n// getting content\n  const value = await Deno.readAll(file)\n// closing file\n  await Deno.close(file.rid)\n// running the native plugin method using Deno dispatch method\n  return (Deno as any).core.dispatch(optimise_native, value)\n}\n')),(0,a.kt)("p",null,"Each plugin is loaded using the ",(0,a.kt)("inlineCode",{parentName:"p"},"openPlugin")," method. Then, the ",(0,a.kt)("inlineCode",{parentName:"p"},"ops")," method is used to get the method identifier, which executes the code exported by the plugin."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"dispatch")," is used to run code exported by the native plugin. The first argument is the method identifier; the rest are passed for the native function. In this case, the file is passed."),(0,a.kt)("h2",{id:"writing-async-plugins"},"Writing async plugins"),(0,a.kt)("p",null,"Since Deno is single-threaded, it\u2019s not wise to block the main thread. Deno allows you to return a future from the native function, which you can use with OS threads to write a function that doesn\u2019t block the main thread."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"fn optimise_async(_interface: &mut dyn Interface,\n    zero_copy: &mut [ZeroCopyBuf],\n) -> Op {\n// get first argument\n    let first=zero_copy.first().unwrap();\n    let opts: oxipng::Options = Default::default();\n    let arg=first.to_vec();\n// create a new future\n    let fut = async move {\n// create a channel to send result once done to main thread\n        let (tx, rx) = futures::channel::oneshot::channel::<oxipng::PngResult<Vec<u8>>>();\n// create a new thread\n        std::thread::spawn(move || {\n// perform work\n          let result = oxipng::optimize_from_memory(&arg, &opts);\n// send result to main thread\n          tx.send(result).unwrap();\n        });\n// receive the result\n        let result=rx.await;\n// create a boxed slice\n        let result_box = result.unwrap().unwrap().into_boxed_slice();\n// return boxed slice from the future\n        result_box\n      };\n// return the future\n    Op::Async(fut.boxed())\n}\n")),(0,a.kt)("p",null,"A future is created using the ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," block and returned as a boxed future. Deno handles the completion of the future and informs the Deno side of the plugin. A channel is used to communicate between the new thread and the main thread."),(0,a.kt)("p",null,"The Deno code doesn\u2019t need much updating \u2014 just a new ",(0,a.kt)("inlineCode",{parentName:"p"},"asyncHandler")," to handle the completion of the task:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'let path = ""\nif (Deno.build.os === "linux") {\n  path = "./native/target/debug/libnative.so"\n} else if (Deno.build.os === "windows") {\n  path = "./native/target/debug/native.dll"\n} else if (Deno.build.os === "darwin") {\n  path = "./native/target/debug/libnative.dylib"\n}\nconst rid = Deno.openPlugin(path);\n\nconst { optimise_async } = (Deno as any).core.ops();\n\nexport async function optimise(fileName: string){\n  const file = await Deno.open(fileName);\n  const value = await Deno.readAll(file);\n  await Deno.close(file.rid);\n// new handler\n  (Deno as any).core.setAsyncHandler(optimise_async, (response:any) => {\n    Deno.writeFile("l.png",response)\n  });\n// executing the native code.\n  (Deno as any).core.dispatch(optimise_async,value);\n}\nawait optimise("t.png")\n\nawait Deno.close(rid);\n')),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this tutorial, we covered how to build a simple Deno plugin using Rust as well as how to create an async plugin using Rust futures and the ",(0,a.kt)("inlineCode",{parentName:"p"},"deno_core")," crate. "),(0,a.kt)("p",null,"Rust has a large ecosystem with high-quality crates. You can use all these crates in Deno by creating plugins. Whether it's an image processing plugin, database connector, etc., access to Rust plugins helps to expand the Deno ecosystem."))}d.isMDXComponent=!0}}]);