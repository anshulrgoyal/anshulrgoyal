(self.webpackChunkanshulrgoyal=self.webpackChunkanshulrgoyal||[]).push([[690],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,g=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(g,i(i({ref:n},c),{},{components:t})):a.createElement(g,i({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9059:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var a=t(2122),r=t(9756),o=(t(7294),t(3905)),i=["components"],s={slug:"grpc-rust",title:"A beginners guide to gRPC with Rust",author:"Anshul Goyal",author_url:"https://github.com/anshulrgoyal",author_image_url:"/img/anshul.jpg",tags:["rust","grpc"]},l="Table of Contents",u={permalink:"/anshulrgoyal/blog/grpc-rust",source:"@site/blog/2020-04-24-rust-grpc.md",title:"A beginners guide to gRPC with Rust",description:"1. Introduction",date:"2020-04-24T00:00:00.000Z",formattedDate:"April 24, 2020",tags:[{label:"rust",permalink:"/anshulrgoyal/blog/tags/rust"},{label:"grpc",permalink:"/anshulrgoyal/blog/tags/grpc"}],readingTime:19.335,truncated:!0,prevItem:{title:"All in one guide for creating a killer API with Strapi",permalink:"/anshulrgoyal/blog/strapi"},nextItem:{title:"Rust and Node.js: A match made in heaven",permalink:"/anshulrgoyal/blog/nodejs-rust-match"}},c=[{value:"Brief Intro to gRPC",id:"brief-intro-to-grpc",children:[]},{value:"A Little about Rust",id:"a-little-about-rust",children:[]},{value:"Syntax",id:"syntax",children:[]},{value:"Compiling Protocol Buffers",id:"compiling-protocol-buffers",children:[]},{value:"Streaming Response",id:"streaming-response",children:[]},{value:"Streaming Request",id:"streaming-request",children:[]},{value:"Bidirectional Stream",id:"bidirectional-stream",children:[]},{value:"Token-Based Authentication",id:"token-based-authentication",children:[]},{value:"Mutual TLS Based Authentication",id:"mutual-tls-based-authentication",children:[]},{value:"Configuring Client and Server",id:"configuring-client-and-server",children:[]}],p={toc:c};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Introduction"),(0,o.kt)("li",{parentName:"ol"},"Protocol Buffer"),(0,o.kt)("li",{parentName:"ol"},"Rust and gRPC"),(0,o.kt)("li",{parentName:"ol"},"Creating a Server"),(0,o.kt)("li",{parentName:"ol"},"Creating a Client"),(0,o.kt)("li",{parentName:"ol"},"Streaming in gRPC"),(0,o.kt)("li",{parentName:"ol"},"Authentication"),(0,o.kt)("li",{parentName:"ol"},"Conclusion")),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"HTTP and JSON is a very popular method for creating web APIs. HTTP and JSON make sense because it uses a very popular protocol. HTTP and JSON are text-based protocol which causes a performance problem since serializing JSON is a slow process, most HTTP and JSON or Rest APIs do not support streaming which means we cannot start processing the data before it arrives. Rest APIs have very good tooling and community support. Almost every programming language has a high-quality implementation for HTTP and serializing JSON. Rest architecture doesn\u2019t fit every use case, it is difficult to provide client library for Rest APIs for every language and maintain these libraries. Since there is no language-independent method for defining the structure of JSON and HTTP requests, therefore, it is difficult to generate client libraries. gRPC is an attempt to tackle these problems."),(0,o.kt)("h2",{id:"brief-intro-to-grpc"},"Brief Intro to gRPC"),(0,o.kt)("p",null,"gRPC is an open-source remote procedure call system developed by Google. gRPC allows the system to communicate in and out of data centers, efficiently transferring data from mobile, IoT devices, backends to one and other. gRPC came with plug able support for load balancing, authentication, tracing, etc. gRPC supports bidirectional streaming over HTTP/2. gRPC provides an idiomatic implementation in 10 languages. gRPC can generate efficient client libraries and uses the protocol buffer format for transferring data over the wire. Protocol buffers are a binary format for data transmission. Since protocol buffers are a binary protocol, it can be serialized fast and the structure of each message must be predefined."),(0,o.kt)("h2",{id:"a-little-about-rust"},"A Little about Rust"),(0,o.kt)("p",null,"Rust is a systems programming language. Rust provides high level ergonomic with low-level control. Rust provides control over memory management without the hassle associated with it. Rust has good support for Asynchronous operation making it a good fit for writing networking applications. Rust has zero cost abstraction making it blazing fast."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587676359774_grpc-2.png",alt:"Work Flow Source(https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/)"})),(0,o.kt)("h1",{id:"protocol-buffers"},"Protocol Buffers"),(0,o.kt)("p",null,"Protocol buffers are extensible, language-neutral data serializing mechanism. It is fast, small, and simple. Protocol buffers have a predefined structure with its syntax for defining messages and services. Services are functions that can be executed and messages are arguments passed to the function and values returned by these functions. There are two versions of protocol buffers. This tutorial would use version 3."),(0,o.kt)("h2",{id:"syntax"},"Syntax"),(0,o.kt)("p",null,"Protocol Buffers have a very simple syntax. There are two things to be defined in a protocol buffer."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"service")," It defines all the functionality that can be called on a particular service or server."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message")," It defines arguments and returns values of an ",(0,o.kt)("inlineCode",{parentName:"li"},"RPC")," call.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"syntax")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"package")," must be defined in every protocol buffer file. Protocol buffer files are saved with ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," extension."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},'    // version of protocol buffer used\n    syntax = "proto3";\n\n    // package name for the buffer will be used later\n    package hello;\n\n    // service which can be executed\n    service Say {\n    // function which can be called\n      rpc Send (SayRequest) returns (SayResponse);\n    }\n\n    // argument\n    message SayRequest {\n    // data type and position of data\n      string name = 1;\n    }\n\n    // return value\n    message SayResponse {\n    // data type and position of data\n      string message = 1;\n    }\n')),(0,o.kt)("p",null,"A service is defined by using ",(0,o.kt)("inlineCode",{parentName:"p"},"service")," keyword then defining call using ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," keyword, ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," is the name of the call, it can be used to make a call, ",(0,o.kt)("inlineCode",{parentName:"p"},"SayRequest")," define the argument ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," call takes and ",(0,o.kt)("inlineCode",{parentName:"p"},"SayResponse")," defines the value returned by the call. Any number of the call can be defined in service."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"    service Say {\n    // function which can be called\n      rpc Send (SayRequest) returns (SayResponse);\n      rpc Take (SayRequest) returns (SayResponse);\n    }\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Implementation of these function is not defined in the")," ",(0,o.kt)("inlineCode",{parentName:"p"},"*.proto*")," ",(0,o.kt)("em",{parentName:"p"},"file, these implementations are provided by the server")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Assign Number to Fields"),"\nThe number assigned to a field is very important because it is used to recognize the field in binary data. It takes 1 byte to encode 0-15 numbers and 2 bytes for encoding 16-2047, it is wise to use 0-15 for frequently occurring data. It is also recommended to reserve a few numbers so that, these reserved numbers can be used later if some changes are made to format."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Different Data Types")),(0,o.kt)("p",null,"Prototype support many data types include string, int, float, boolean, etc. These types can be repeated using ",(0,o.kt)("inlineCode",{parentName:"p"},"repeated")," field attributes."),(0,o.kt)("p",null,"Protocol buffer syntax is explained in great detail in ",(0,o.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers/docs/proto"},"official documentation.")),(0,o.kt)("h1",{id:"rust-and-grpc"},"Rust and gRPC"),(0,o.kt)("p",null,"Rust ecosystem has grown quite big with very good quality crates. ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic")," is very performant gRPC implementation for Rust. This tutorial uses ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic")," as the gRPC implementation and ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic-build")," for compiling ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," files to client libraries.\nLet us start by creating a new cargo project using ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo init"),". Now we need to create an add a few dependencies and build dependencies. These will help us with our server and client."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'    [package]\n    name = "grpc"\n    version = "0.1.0"\n    authors = ["Anshul Goyal <anshulgoel151999@gmail.com>"]\n    edition = "2018"\n\n    [dependencies]\n    prost = "0.6.1"\n    tonic = {version="0.2.0",features = ["tls"]}\n    tokio = {version="0.2.18",features = ["stream", "macros"]}\n    futures = "0.3"\n\n    [build-dependencies]\n    tonic-build = "0.2.0"\n')),(0,o.kt)("p",null,"This should be a configuration for ",(0,o.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file. ",(0,o.kt)("inlineCode",{parentName:"p"},"prost")," provides basic types for gRPC, ",(0,o.kt)("inlineCode",{parentName:"p"},"tokio")," provide asynchronous runtime and ",(0,o.kt)("inlineCode",{parentName:"p"},"futures")," for handling asynchronous streams."),(0,o.kt)("h2",{id:"compiling-protocol-buffers"},"Compiling Protocol Buffers"),(0,o.kt)("p",null,"We would use ",(0,o.kt)("inlineCode",{parentName:"p"},"build.rs")," for compiling our ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," files and include then in binary. ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic-build")," crate provides a method ",(0,o.kt)("inlineCode",{parentName:"p"},"compile_protos")," which take the path to ",(0,o.kt)("inlineCode",{parentName:"p"},".ptoto")," file and compile it to rust definitions. First, we create a folder in the root directory named ",(0,o.kt)("inlineCode",{parentName:"p"},"proto")," it will contain all of out ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," files. We create a ",(0,o.kt)("inlineCode",{parentName:"p"},"say.proto")," file in this directory. With our ",(0,o.kt)("inlineCode",{parentName:"p"},"Say")," service shown in the above example."),(0,o.kt)("p",null,"We create a ",(0,o.kt)("inlineCode",{parentName:"p"},"build.rs")," with the following code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn main()->Result<(),Box<dyn std::error::Error>>{\n    // compiling protos using path on build time\n       tonic_build::compile_protos("proto/say.proto")?;\n       Ok(())\n    }\n')),(0,o.kt)("p",null,"The above code will compile ",(0,o.kt)("inlineCode",{parentName:"p"},"proto/say.proto")," file and save it in an ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT_DIR")," and add an environment variable ",(0,o.kt)("inlineCode",{parentName:"p"},"OUT_DIR")," which is available at build time so that we can use it later in our code. We can also provide different options for compiling the protocol buffers. Now your directory structure should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    \u251c\u2500\u2500 build.rs\n    \u251c\u2500\u2500 Cargo.lock\n    \u251c\u2500\u2500 Cargo.toml\n    \u251c\u2500\u2500 proto\n    \u2502   \u2514\u2500\u2500 say.proto\n    \u251c\u2500\u2500 src\n        \u251c\u2500\u2500 main.rs\n")),(0,o.kt)("p",null,"Now we have compiled our ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," files we would use it in our code using ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic")," utility. We would create a module for our server and client. Let us name it ",(0,o.kt)("inlineCode",{parentName:"p"},"hell.rs")," and we would add the following code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    // this would include code generated for package hello from .proto file\n    tonic::include_proto!("hello");\n\n')),(0,o.kt)("h1",{id:"creating-a-server"},"Creating a Server"),(0,o.kt)("p",null,"Now we have compiled the protocol buffers we are ready to build our server. We have to provide the implementation for every service and ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," we defined. Service would be defined as traits and ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," would be a member function on these traits. Since Rust doesn't support async traits we have to use an ",(0,o.kt)("inlineCode",{parentName:"p"},"asyc_trait")," macro for overcoming this limitation. We create a file named ",(0,o.kt)("inlineCode",{parentName:"p"},"server.rs")," and add the following code."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"**tonic-build**")," ",(0,o.kt)("strong",{parentName:"p"},"would automatically compile")," ",(0,o.kt)("inlineCode",{parentName:"p"},"**.proto**")," ",(0,o.kt)("strong",{parentName:"p"},"following rust naming conventions and best practices.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use tonic::{transport::Server, Request, Response, Status};\n    use hello::say_server::{Say, SayServer};\n    use hello::{SayResponse, SayRequest};\n    mod hello;\n\n    // defining a struct for our service\n    #[derive(Default)]\n    pub struct MySay {}\n\n    // implementing rpc for service defined in .proto\n    #[tonic::async_trait]\n    impl Say for MySay {\n    // our rpc impelemented as function\n        async fn send(&self,request:Request<SayRequest>)->Result<Response<SayResponse>,Status>{\n    // returning a response as SayResponse message as defined in .proto\n            Ok(Response::new(SayResponse{\n    // reading data from request which is awrapper around our SayRequest message defined in .proto\n                 message:format!("hello {}",request.get_ref().name),\n            }))\n        }\n    }\n\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // defining address for our service\n        let addr = "[::1]:50051".parse().unwrap();\n    // creating a service\n        let say = MySay::default();\n        println!("Server listening on {}", addr);\n    // adding our service to our server.\n        Server::builder()\n            .add_service(SayServer::new(say))\n            .serve(addr)\n            .await?;\n        Ok(())\n    }\n')),(0,o.kt)("p",null,"In Rust, messages are represented as structs and services as traits and RPC as functions. We ",(0,o.kt)("inlineCode",{parentName:"p"},"impl")," the trait for our struct and pass it to our server. In our example, we would create a send function which takes ",(0,o.kt)("inlineCode",{parentName:"p"},"Request")," as an argument which contains details about the request and wraps our message ",(0,o.kt)("inlineCode",{parentName:"p"},"SayRequest")," which can be accessed using ",(0,o.kt)("inlineCode",{parentName:"p"},".get_ref")," method. Now let us run this by adding a bin block to our ",(0,o.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'    [[bin]]\n    name = "server"\n    path = "src/server.rs"\n')),(0,o.kt)("p",null,"This will help us testing and maintaining code in save repo but it is not suggested for a large project.\nNow if we run this with command ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo run")," ",(0,o.kt)("inlineCode",{parentName:"p"},"--``bin server"),". We can see our server running at ",(0,o.kt)("inlineCode",{parentName:"p"},"127:0:0:1:50051"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587642193283_image.png",alt:"Example"})),(0,o.kt)("h1",{id:"creating-a-client"},"Creating a Client"),(0,o.kt)("p",null,"Our server is ready, now let's test it by creating a client. Since we have compiled our protocol buffer we can import our ",(0,o.kt)("inlineCode",{parentName:"p"},"hello.rs")," file and use it. We create a ",(0,o.kt)("inlineCode",{parentName:"p"},"client.rs")," file and add the following code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use hello::say_client::SayClient;\n    use hello::SayRequest;\n\n    mod hello;\n\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // creating a channel ie connection to server\n        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n        .connect()\n        .await?;\n    // creating gRPC client from channel\n        let mut client = SayClient::new(channel);\n    // creating a new Request\n        let request = tonic::Request::new(\n            SayRequest {\n               name:String::from("anshul")\n            },\n        );\n    // sending request and waiting for response\n        let response = client.send(request).await?.into_inner();\n        println!("RESPONSE={:?}", response);\n        Ok(())\n    }\n')),(0,o.kt)("p",null,"We add a bin key to our ",(0,o.kt)("inlineCode",{parentName:"p"},"Cargo.toml")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'    [[bin]]\n    name = "client"\n    path = "src/client.rs"\n')),(0,o.kt)("p",null,"We create a channel that is an HTTP/2 connection that can be used then from our client. HTTP/2 support streams that can be used by gRPC. Now if we run our client with command ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo run")," ",(0,o.kt)("inlineCode",{parentName:"p"},"--bin client")," we can see see the response."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587643536436_image.png",alt:null})),(0,o.kt)("h1",{id:"error-handling"},"Error Handling"),(0,o.kt)("p",null,"Error handling in gRPC is done using Status. ",(0,o.kt)("inlineCode",{parentName:"p"},"tonic")," provide ",(0,o.kt)("inlineCode",{parentName:"p"},"Status")," enum which can be returned in case of error with appropriate error message."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    Err(Status::unauthenticated("Token not found"))\n')),(0,o.kt)("p",null,"gRPC support bare-bone error handling but you can extend yourself using protocol buffer here is ",(0,o.kt)("a",{parentName:"p",href:"https://cloud.google.com/apis/design/errors#error_model"},"detail explanation")),(0,o.kt)("h1",{id:"streaming-in-grpc"},"Streaming In gRPC"),(0,o.kt)("p",null,"HTTP/2 supports streaming and gRPC provides a nice interface for using it. We can start sending the response even before the client finish sends the request. We can use it to provide an efficient service. The server has not to wait for the request from the client to complete the request. We need to make a few changes to our protocol buffers so that it reflects that we support streaming. We need to make changes to our rust code also. Rust has quite good support for asynchronous I/O. We would ",(0,o.kt)("inlineCode",{parentName:"p"},"tokio")," to stream response and request."),(0,o.kt)("h2",{id:"streaming-response"},"Streaming Response"),(0,o.kt)("p",null,"We would start by the streaming server since most of the time server would be sending a large amount of data. We would use a queue for sending data by multiplexing different task on a single thread. ",(0,o.kt)("inlineCode",{parentName:"p"},"tokio")," provide very excellent multi sender single receiver channel."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes to protocol buffers")),(0,o.kt)("p",null,"We change the code of protocol buffer to the following. We use a stream keyword in ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," and specify that the ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," call will return a stream of messages ",(0,o.kt)("inlineCode",{parentName:"p"},"SayResponse"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    service Say {\n    // function which can be called\n      rpc Send (SayRequest) returns (SayResponse);\n    // we specify that we return a stream\n      rpc SendStream(SayRequest) returns (stream SayResponse);\n    }\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes to Server Code"),"\nWe would use ",(0,o.kt)("inlineCode",{parentName:"p"},"tokio::sync::mpsc")," for communicating between futures. We send multiple responses using this channel. We would use ",(0,o.kt)("inlineCode",{parentName:"p"},"tokio::spawn")," to create a new task that can be then scheduled. We add the following code to our ",(0,o.kt)("inlineCode",{parentName:"p"},"server.rs")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use tokio::sync::mpsc;\n    use tonic::{transport::Server, Request, Response, Status};\n    use hello::say_server::{Say, SayServer};\n    use hello::{SayRequest, SayResponse};\n    mod hello;\n\n    #[derive(Default)]\n    pub struct MySay {}\n    #[tonic::async_trait]\n    impl Say for MySay {\n    // Specify the output of rpc call\n        type SendStreamStream=mpsc::Receiver<Result<SayResponse,Status>>;\n    // implementation for rpc call\n        async fn send_stream(\n            &self,\n            request: Request<SayRequest>,\n        ) -> Result<Response<Self::SendStreamStream>, Status> {\n    // creating a queue or channel\n            let (mut tx, rx) = mpsc::channel(4);\n    // creating a new task\n            tokio::spawn(async move {\n    // looping and sending our response using stream\n                for _ in 0..4{\n    // sending response to our channel\n                    tx.send(Ok(SayResponse {\n                        message: format!("hello"),\n                    }))\n                    .await;\n                }\n            });\n    // returning our reciever so that tonic can listen on reciever and send the response to client\n            Ok(Response::new(rx))\n        }\n        async fn send(&self, request: Request<SayRequest>) -> Result<Response<SayResponse>, Status> {\n            Ok(Response::new(SayResponse {\n                message: format!("hello {}", request.get_ref().name),\n            }))\n        }\n    }\n\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let addr = "[::1]:50051".parse().unwrap();\n        let say = MySay::default();\n        println!("Server listening on {}", addr);\n        Server::builder()\n            .add_service(SayServer::new(say))\n            .serve(addr)\n            .await?;\n        Ok(())\n    }\n')),(0,o.kt)("p",null,"We need to change the main function, we just add a new function to trait and a type to specify our output. In this new ",(0,o.kt)("inlineCode",{parentName:"p"},"send_stream")," function we create a channel so that we can send a response and return the receiver. The receiver implements the",(0,o.kt)("inlineCode",{parentName:"p"},"Stream")," trait so it can be streamed by HTTP/2 and the sender can be used by multiple threads and it implements ",(0,o.kt)("inlineCode",{parentName:"p"},"Sink")," trait. We have created a bounded channel but we can also use an unbounded channel."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes in Client Code"),"\nWe need to make changes to response handling. Since it would be a stream now, we would just listen to this stream and print the response. Streams help to write non-blocking code and use resources more efficiently."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use hello::say_client::SayClient;\n    use hello::SayRequest;\n    mod hello;\n\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n        .connect()\n        .await?;\n        let mut client = SayClient::new(channel);\n        let request = tonic::Request::new(\n            SayRequest {\n               name:String::from("anshul")\n            },\n        );\n    // now the response is stream\n        let mut response = client.send_stream(request).await?.into_inner();\n    // listening to stream\n        while let Some(res) = response.message().await? {\n            println!("NOTE = {:?}", res);\n        }\n        Ok(())\n    }\n')),(0,o.kt)("h2",{id:"streaming-request"},"Streaming Request"),(0,o.kt)("p",null,"Sometimes all the data is not available, for example in a game all the data is not available then it would make stream the data and send all the data available and sending rest when available. This allows using data more efficiently on user devices. We need a few changes to our code."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes to protocol buffer"),"\nWe would use the ",(0,o.kt)("inlineCode",{parentName:"p"},"stream")," keyword to specify the argument is a stream. We would use ",(0,o.kt)("inlineCode",{parentName:"p"},"stream")," to specify that our ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc")," takes a stream as an argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    // service which can be executed\n    service Say {\n    // function which can be called\n      rpc Send (SayRequest) returns (SayResponse);\n      rpc SendStream(SayRequest) returns (stream SayResponse);\n    // taking a stream as response\n      rpc ReceiveStream(stream SayRequest) returns (SayResponse);\n    }\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes to Server"),"\nWe need our server to accept the stream as the request. We would listen on the stream and collect. Then we would respond when the stream finishes. It will save our resources since we can wait on stream asynchronously."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use tokio::sync::mpsc;\n    use tonic::{transport::Server, Request, Response, Status};\n    use hello::say_server::{Say, SayServer};\n    use hello::{SayRequest, SayResponse};\n    mod hello;\n    #[derive(Default)]\n    pub struct MySay {}\n    #[tonic::async_trait]\n    impl Say for MySay {\n    // .. rest of rpcs\n    // create a new rpc to receive a stream\n        async fn receive_stream(\n            &self,\n            request: Request<tonic::Streaming<SayRequest>>,\n        ) -> Result<Response<SayResponse>, Status> {\n    // converting request into stream\n            let mut stream = request.into_inner();\n            let mut message = String::from("");\n    // listening on stream\n            while let Some(req) = stream.message().await? {\n                message.push_str(&format!("Hello {}\\n", req.name))\n            }\n    // returning response\n            Ok(Response::new(SayResponse { message }))\n        }\n    }\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let addr = "[::1]:50051".parse().unwrap();\n        let say = MySay::default();\n        println!("Server listening on {}", addr);\n        Server::builder()\n            .add_service(SayServer::new(say))\n            .serve(addr)tes());\n            .await?;\n        Ok(())\n    }\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Changes to Client"),"\nWe would now program our client to send a stream to our server. For this, we would mimic a stream using ",(0,o.kt)("inlineCode",{parentName:"p"},"futures")," crate and create a stream from a vector."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use futures::stream::iter;\n    use hello::say_client::SayClient;\n    use hello::SayRequest;\n    mod hello;\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n            .connect()\n            .await?;\n        let mut client = SayClient::new(channel);\n    // creating a stream\n        let request = tonic::Request::new(iter(vec![\n            SayRequest {\n                name: String::from("anshul"),\n            },\n            SayRequest {\n                name: String::from("rahul"),\n            },\n            SayRequest {\n                name: String::from("vijay"),\n            },\n        ]));\n    // sending stream\n        let response = client.receive_stream(request).await?.into_inner();\n        println!("RESPONSE=\\n{}", response.message);\n        Ok(())\n    }\n')),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587657121220_image.png",alt:null})),(0,o.kt)("h2",{id:"bidirectional-stream"},"Bidirectional Stream"),(0,o.kt)("p",null,"The bidirectional stream is also supported by gRPC. The bidirectional stream is just a combination of streaming requests and streaming responses. Here is a quick example."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Protocol buffer")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'\n    // version of protocol buffer used\n    syntax = "proto3";\n    // package name for buffer will be used later\n    package hello;\n    // service which can be executed\n    service Say {\n    // takes a stream and returns a stream\n      rpc Bidirectional(stream SayRequest) returns (stream SayResponse);\n    }\n    // argument\n    message SayRequest {\n    // data type and position of data\n      string name = 1;\n    }\n    // return value\n    message SayResponse {\n    // data type and position of data\n      string message = 1;\n    }\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Sever")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use tokio::sync::mpsc;\n    use tonic::{transport::Server, Request, Response, Status};\n    use hello::say_server::{Say, SayServer};\n    use hello::{SayRequest, SayResponse};\n    mod hello;\n    #[derive(Default)]\n    pub struct MySay {}\n    #[tonic::async_trait]\n    impl Say for MySay {\n    // defining return stream\n        type BidirectionalStream = mpsc::Receiver<Result<SayResponse, Status>>;\n        async fn bidirectional(\n            &self,\n            request: Request<tonic::Streaming<SayRequest>>,\n        ) -> Result<Response<Self::BidirectionalStream>, Status> {\n    // converting request in stream\n            let mut streamer = request.into_inner();\n    // creating queue\n            let (mut tx, rx) = mpsc::channel(4);\n            tokio::spawn(async move {\n    // listening on request stream\n                while let Some(req) = streamer.message().await.unwrap(){\n    // sending data as soon it is available\n                    tx.send(Ok(SayResponse {\n                        message: format!("hello {}", req.name),\n                    }))\n                    .await;\n                }\n            });\n    // returning stream as receiver\n            Ok(Response::new(rx))\n        }\n    }\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let addr = "[::1]:50051".parse().unwrap();\n        let say = MySay::default();\n        println!("Server listening on {}", addr);\n        Server::builder()\n            .add_service(SayServer::new(say))\n            .serve(addr)\n            .await?;\n        Ok(())\n    }\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Client")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    use futures::stream::iter;\n    use hello::say_client::SayClient;\n    use hello::SayRequest;\n    mod hello;\n    #[tokio::main]\n    async fn main() -> Result<(), Box<dyn std::error::Error>> {\n        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n            .connect()\n            .await?;\n        let mut client = SayClient::new(channel);\n    // creating a client\n        let request = tonic::Request::new(iter(vec![\n            SayRequest {\n                name: String::from("anshul"),\n            },\n            SayRequest {\n                name: String::from("rahul"),\n            },\n            SayRequest {\n                name: String::from("vijay"),\n            },\n        ]));\n    // calling rpc\n        let mut response = client.bidirectional(request).await?.into_inner();\n    // listening on the response stream\n        while let Some(res) = response.message().await? {\n            println!("NOTE = {:?}", res);\n        }\n        Ok(())\n    }\n')),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587658480089_image.png",alt:"Example"})),(0,o.kt)("h1",{id:"authentication"},"Authentication"),(0,o.kt)("p",null,"Authentication is a very important aspect of a system. gRPC comes with plug able authentication support. gRPC support mainly two types of authentication:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Token-based authentication"),(0,o.kt)("li",{parentName:"ul"},"TLS based authentication")),(0,o.kt)("h2",{id:"token-based-authentication"},"Token-Based Authentication"),(0,o.kt)("p",null,"In this tutorial, we would use JWT based authentication. JWT or JSON web token provides an open-source and stateless authentication mechanism. We would ",(0,o.kt)("inlineCode",{parentName:"p"},"jsonwebtoken")," crate for creating JWT and validating it. We would just see how we can use JWT with gRPC."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Server"),"\nWe would need to add an interceptor, that would validate token, if the token is not valid, we would just close the request, if the token is valid then we forward the request to our handlers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn interceptor(req:Request<()>)->Result<Request<()>,Status>{\n        let token=match req.metadata().get("authorization"){\n            Some(token)=>token.to_str(),\n            None=>return Err(Status::unauthenticated("Token not found"))\n        };\n        // do some validation with token here ...\n        Ok(req)\n    }\n')),(0,o.kt)("p",null,"If we return ",(0,o.kt)("inlineCode",{parentName:"p"},"Ok")," then the request would be passed on to functions but if we return ",(0,o.kt)("inlineCode",{parentName:"p"},"Err")," with status the request is closed with provided status. We create a service with this interceptor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    let say = MySay::default();\n    let ser = SayServer::with_interceptor(say,interceptor);\n    Server::builder().add_service(ser).serve(addr).await?;\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Client"),"\nWe need to add an interceptor to our client also. We would add it to our main function as a closure."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n            .connect()\n            .await?;\n        let token = get_token();// an method to get token can be a rpc call etc.\n        let mut client = SayClient::with_interceptor(channel, move |mut req: Request<()>| {\n    // adding token to request.\n            req.metadata_mut().insert(\n                "authorization",\n                tonic::metadata::MetadataValue::from_str(&token).unwrap(),\n            );\n            Ok(req)\n        });\n')),(0,o.kt)("h2",{id:"mutual-tls-based-authentication"},"Mutual TLS Based Authentication"),(0,o.kt)("p",null,"TLS stands for Transport Layer Security, it is recommended by gRPC documentation to encrypt HTTP/2 connection with TLS. We would TLS to authenticate both client and server. This is called Mutual TLS. We would create a private key and public key for both client and server. We would also create a Certificate Authority certificate so that we can sign our TLS certificate. We would require OpenSSL for creating certificates."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Creating Certificates")),(0,o.kt)("p",null,"OpenSSL is a command-line utility for creating keys and encryption-related stuff. We would start by creating a Certification Authority certificate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"openssl genrsa -des3 -out my_ca.key 2048\n")),(0,o.kt)("p",null,"This would act as our signing key. We would use it to sign our TLS certificate. Next, we create our certificate which is called the root CA certificate. It is used to validate if our TLS certificate is\nvalidated or not."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"openssl req -x509 -new -nodes -key my_ca.key -sha256 -days 1825 -out my_ca.pem\n")),(0,o.kt)("p",null,"This command would ask you a few questions. Details enter in this doesn\u2019t matter. If you can get this certificate on every device on earth you become a certificate signing authority like Let\u2019s Encrypt etc. Now let's create our server key and certificate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"openssL genrsa -out server.key 2048\n")),(0,o.kt)("p",null,"This command will generate a key for our server. Now we create a certificate signing request for our key."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"openssl req -new -sha256 -key server.key -out server.csr\n")),(0,o.kt)("p",null,"This would ask you some questions. Now we create a ",(0,o.kt)("inlineCode",{parentName:"p"},"server.ext")," file. This file would contain our name, our domain, or subdomain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"authorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = localhost\n")),(0,o.kt)("p",null,"We add our identity in the form of DNS. Now we run the following command"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"openssl x509 -req -in server.csr -CA my_ca.pem -CAkey my_ca.key -CAcreateserial -out server.pem -days 1825 -sha256 -extfile server.ext\n")),(0,o.kt)("p",null,"You don\u2019t need to provide your private key or server key. This might ask you a few questions and passcode provided when generating the Certificate Authority key.\nYou can generate a Certificate for the client using the same certificate authority. Now we have all the required certificates to let configure our server and client."),(0,o.kt)("h2",{id:"configuring-client-and-server"},"Configuring Client and Server"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"tonic")," support TLS using ",(0,o.kt)("inlineCode",{parentName:"p"},"rust-tls"),". We can configure TLS by following the method."),(0,o.kt)("p",null,"This shows how to configure the client for TLS."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'        // getting certificate from disk\n        let cert=include_str!("../client.pem");\n        let key=include_str!("../client.key");\n        // creating identify from key and certificate\n        let id=tonic::transport::Identity::from_pem(cert.as_bytes(),key.as_bytes());\n        // importing our certificate for CA\n        let s=include_str!("../my_ca.pem");\n        // converting it into a certificate\n        let ca=tonic::transport::Certificate::from_pem(s.as_bytes());\n        // telling our client what is the identity of our server\n        let tls=tonic::transport::ClientTlsConfig::new().domain_name("localhost").identity(id).ca_certificate(ca);\n        // connecting with tls\n        let channel = tonic::transport::Channel::from_static("http://[::1]:50051")\n            .tls_config(tls)\n            .connect()\n            .await?;\n')),(0,o.kt)("p",null,"This shows how to configure for TLS."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'        let say = MySay::default();\n    // reading cert and key disk\n        let cert = include_str!("../server.pem");\n        let key = include_str!("../server.key");\n    // creating identity from cert and key\n        let id = tonic::transport::Identity::from_pem(cert.as_bytes(), key.as_bytes());\n    // reading ca root from disk\n        let s = include_str!("../my_ca.pem");\n    // creating certificate\n        let ca = tonic::transport::Certificate::from_pem(s.as_bytes());\n    // creating tls config\n        let tls = tonic::transport::ServerTlsConfig::new()\n            .identity(id)\n            .client_ca_root(ca);\n    // creating server with tls\n        Server::builder()\n            .tls_config(tls)\n            .add_service(ser)\n            .serve(addr)\n            .await?;\n        Ok(())\n\n')),(0,o.kt)("h1",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"We have gone through basic protocol buffer and gRPC. We have created our server. We also created a client for interacting with the server. We learned how to compile our ",(0,o.kt)("inlineCode",{parentName:"p"},".proto")," file in rust client. We also learned how to stream responses and requests. We also created a bidirectional stream. We learned two different authentication strategy. We implemented JWT and Mutual TLS based authentication. Now you have a basic understanding of gRPC, you can create your own micro-service based app. gRPC comes with support for load-balancing,tracing and health tracking. Now you can explore further functionality of gRPC."))}d.isMDXComponent=!0}}]);