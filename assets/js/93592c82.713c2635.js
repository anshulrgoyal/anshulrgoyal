(self.webpackChunkanshulrgoyal=self.webpackChunkanshulrgoyal||[]).push([[8768],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return h},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,m=d["".concat(l,".").concat(c)]||d[c]||u[c]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6336:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return h},default:function(){return d}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),i=["components"],s={title:"A Practical Guide for JWT Authentication Using Node.js and Express",slug:"jwt-auth",author:"Anshul Goyal",author_url:"https://github.com/anshulrgoyal",author_image_url:"/img/anshul.jpg",tags:["jwt","auth","nodejs","express"],image:"https://cdn-images-1.medium.com/max/10836/1*WrDrIa0v80eL43PK-Wtu-w.jpeg"},l="Introduction",p={permalink:"/anshulrgoyal/blog/jwt-auth",source:"@site/blog/2019-01-14-jwt-auth.md",title:"A Practical Guide for JWT Authentication Using Node.js and Express",description:"Traditional authentication strategy makes use of sessions and cookies, but scaling these solutions is very difficult \u2014 as some kind of state is maintained by the server. JWT, on the other hand, provides a stateless solution for authentication, and stateless applications are pretty easy to scale.",date:"2019-01-14T00:00:00.000Z",formattedDate:"January 14, 2019",tags:[{label:"jwt",permalink:"/anshulrgoyal/blog/tags/jwt"},{label:"auth",permalink:"/anshulrgoyal/blog/tags/auth"},{label:"nodejs",permalink:"/anshulrgoyal/blog/tags/nodejs"},{label:"express",permalink:"/anshulrgoyal/blog/tags/express"}],readingTime:6.65,truncated:!0,prevItem:{title:"Setting A React Project From Scratch Using Babel And Webpack",permalink:"/anshulrgoyal/blog/react-setup"}},h=[],u={toc:h};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Traditional authentication strategy makes use of sessions and cookies, but scaling these solutions is very difficult \u2014 as some kind of state is maintained by the server. JWT, on the other hand, provides a stateless solution for authentication, and stateless applications are pretty easy to scale."),(0,o.kt)("h4",{id:"advantages-of-jwt"},"Advantages of JWT"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Provides a stateless authentication solution")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Very popular and used by many OAuth service providers, like Google and Facebook")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It\u2019s very easy to verify a JWT token")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"More trustworthy than cookies and sessions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Authentication can be outsourced, or an authentication service can be used")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Have many applications other than authentication \u2014 for instance, it can be used for claims"))),(0,o.kt)("h4",{id:"content"},"Content"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"JWT structure and overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The JWT authentication mechanism")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Using JWT authentication with Node.js"))),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"whats-jwt"},"What\u2019s JWT?"),(0,o.kt)("p",null,"A JSON Web Token (JWT) is a ",(0,o.kt)("a",{parentName:"p",href:"http://www.w3schools.com/json/"},"JSON object")," that\u2019s defined in ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7519"},"RFC 7519")," as a safe way to represent a set of information between two parties. The token is composed of a header, a payload, and a signature."),(0,o.kt)("p",null,"JWT is used for authentication, and they can also be used for sharing information. Most JWT are signed using a public key and a private key; therefore, it\u2019s very difficult to tamper with these tokens. JWT has three parts: head, body and signature, each separated by ",(0,o.kt)("inlineCode",{parentName:"p"},"\u201c.\u201d"),"."),(0,o.kt)("h4",{id:"head"},"Head"),(0,o.kt)("p",null,"The head is a ",(0,o.kt)("inlineCode",{parentName:"p"},"base64Url"),(0,o.kt)("strong",{parentName:"p"},"-"),"encoded, stringified JS object that contains information about the token. The head contains the type of token, the content type of the token, and an algorithm used to sign that token. The type is specified by the field type and the algorithm used to sign the token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n')),(0,o.kt)("p",null,"The object is then converted to a string and encoded to ",(0,o.kt)("inlineCode",{parentName:"p"},"Base64Url"),"."),(0,o.kt)("p",null,"The following code shows how to change the encoding using the buffer module in Node.js."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Buffer.from(JSON.stringify({\n"alg": "HS256",\n"typ": "JWT"\n})).toString(\'base64\')\n.replace(/=/g, "")\n.replace(/\\+/g, "-")\n.replace(/\\//g, "_");\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note: "),(0,o.kt)("inlineCode",{parentName:"p"},"Base64")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Base64URL")," are the same; however, ",(0,o.kt)("inlineCode",{parentName:"p"},"+")," is converted to ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," is converted to ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," ."),(0,o.kt)("p",null,"This is done to ensure there\u2019s no collision between the query string and the token since ",(0,o.kt)("inlineCode",{parentName:"p"},"+")," has a special meaning in the query string (the same goes for ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),")."),(0,o.kt)("h4",{id:"body"},"Body"),(0,o.kt)("p",null,"The body is the as the head, but it contains the claim or data that\u2019s transferred."),(0,o.kt)("p",null,"The body may contain special attributes like ",(0,o.kt)("inlineCode",{parentName:"p"},"iss")," , ",(0,o.kt)("inlineCode",{parentName:"p"},"sub")," , ",(0,o.kt)("inlineCode",{parentName:"p"},"aud"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"exp"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"iat"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"jti"),", etc. These attributes have a standard implementation and are accepted by most OAuth services. Some interesting ones are ",(0,o.kt)("inlineCode",{parentName:"p"},"exp")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"iat"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"exp")," specifies the time after which the token will become invalid, and ",(0,o.kt)("inlineCode",{parentName:"p"},"iat")," specifies the time when the token was created."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{\n  "sub": "90129920",\n  "uuid": "sfgdsrfg434fdt535fg",\n  "iat": 1516239022,\n  "exp": 1545926973,\n}\n')),(0,o.kt)("p",null,"The time is used in seconds, following the 1 January 1970 format. The body is also converted to ",(0,o.kt)("inlineCode",{parentName:"p"},"Base64URL")," using the same code as used in the head."),(0,o.kt)("h4",{id:"signature"},"Signature"),(0,o.kt)("p",null,"This is the most important part of the token because it\u2019s used to verify if the token is valid and authentic. Let\u2019s see how the signature is created."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'signature=sha256(base64URL(head)+"."+base64URL(body))\n')),(0,o.kt)("p",null,"The token consists of the body and the head encrypted using any hashing algorithm \u2014 for example, SHA-256."),(0,o.kt)("p",null,"The algorithm can be symmetrical or asymmetrical. It depends upon the needs of the application. The example below shows how we can create a signature for JWT."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const crypto=require('crypto');\nconst private_key=\"dfhghhghgdoghoghg\";\nconst sign = crypto.createHmac('SHA256', private_key)\n.update(head + '.' + body)\n.digest('base64')\n.replace(/=/g, \"\")\n.replace(/\\+/g, \"-\")\n.replace(/\\//g, \"_\")\n")),(0,o.kt)("p",null,"First, we create a stream from ",(0,o.kt)("inlineCode",{parentName:"p"},"crypto.createHmac"),". We push the ",(0,o.kt)("inlineCode",{parentName:"p"},"base64url"),"-encoded head and body (separated by ",(0,o.kt)("inlineCode",{parentName:"p"},"\u201c.\u201d"),") to the created stream. Then, we convert the buffer to the ",(0,o.kt)("inlineCode",{parentName:"p"},"base64"),"-encoded string and then to the ",(0,o.kt)("inlineCode",{parentName:"p"},"base64url"),"-encoded string."),(0,o.kt)("h4",{id:"verification"},"Verification"),(0,o.kt)("p",null,"When the server verifies the token, it creates the ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," using the private key. If the ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," matches the signature on the token, then the token is authentic."),(0,o.kt)("p",null,"If the token is tempered with, the ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," of the token should change. But the hacker can\u2019t create the new ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," because the key is saved with the server. Therefore, the token is verified, and the client can also be verified using the data in the body."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'token=base64url(head)+"."+baser64url(body)+"."+signature\n')),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"how-does-authentication-with-jwt-work"},"How Does Authentication With JWT Work?"),(0,o.kt)("p",null,"The token with ",(0,o.kt)("inlineCode",{parentName:"p"},"user_id")," is given to the client, and the client sends the token back to the server every time the client makes an HTTP request to the server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'body={\n user_id:"123nfdwf283",\n}\n')),(0,o.kt)("p",null,"The client must store the token in the browser. The token can be saved in local storage or session storage. Using local storage will keep the user signed in until the token expires, and session storage will keep the user logged in until the browser tab is closed. The token is sent to the server in the authorization header as ",(0,o.kt)("inlineCode",{parentName:"p"},"Bearer {token}"),"."),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"using-jwt-with-nodejs"},"Using JWT With Node.js"),(0,o.kt)("p",null,"If you don't want to write your own custom JWT solution, you can always use an npm module for it. We\u2019d first install Express and the ",(0,o.kt)("a",{parentName:"p",href:"https://jwt.io/"},"JSON Web Tokens library"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm i express jsonwebtoken mongoose body-parser bcrypt\n")),(0,o.kt)("p",null,"The directory structure of the project:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"root\n   -app.js\n   -user.js\n   -key.js\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"key.js")," contains the private key, but it\u2019s not a good practice. You should always use an ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," variable for such sensitive data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'module.exports={tokenKey:"djghhhhuuwiwuewieuwieuriwu"}\n')),(0,o.kt)("p",null,"The user schema consists of a presave hook. When we create a new user, the password is converted to ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"salt")," using bcryptjs. A static method is also added to the schema for comparing passwords using ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," and",(0,o.kt)("inlineCode",{parentName:"p"},"salt"),"."),(0,o.kt)("p",null,"Passwords are never saved in the database. The passwords are converted to a ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," using any hashing algorithm, with the help of ",(0,o.kt)("inlineCode",{parentName:"p"},"salt"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"salt")," acts as the private key for the creating the ",(0,o.kt)("inlineCode",{parentName:"p"},"hash"),". When the user provides a password for login, the password and ",(0,o.kt)("inlineCode",{parentName:"p"},"salt")," are used to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"hash"),". The created ",(0,o.kt)("inlineCode",{parentName:"p"},"hash")," is then matched with the stored one. If both ",(0,o.kt)("inlineCode",{parentName:"p"},"hash"),"es match, then the password is matched."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"var mongoose = require('mongoose');\nvar bcrypt = require('bcryptjs')\nvar userSchema = new mongoose.Schema({\n    first: String,\n    email: {type:String,unique:true},\n    password: String,\n    image:String\n},{timestamps:true})\n\nuserSchema.pre('save', function (next) {\n    var user = this;\n    if (!user.isModified('password')) {return next()};\n    bcrypt.hash(user.password,10).then((hashedPassword) => {\n        user.password = hashedPassword;\n        next();\n    })\n}, function (err) {\n    next(err)\n})\nuserSchema.methods.comparePassword=function(candidatePassword,next){    bcrypt.compare(candidatePassword,this.password,function(err,isMatch){\n        if(err) return next(err);\n        next(null,isMatch)\n    })\n}\nmodule.exports = mongoose.model(\"user\", userSchema);\n")),(0,o.kt)("p",null,"Let\u2019s create a simple Express server."),(0,o.kt)("p",null,"The route ",(0,o.kt)("inlineCode",{parentName:"p"},"/api/auth/signin")," first matches the password and then issues a token to the user. The token is sent by the user to the server every time in the request header, and the token is parsed by the ",(0,o.kt)("inlineCode",{parentName:"p"},"app.use")," middleware every time."),(0,o.kt)("p",null,"The middleware also adds user details to the req as ",(0,o.kt)("inlineCode",{parentName:"p"},"req.user")," . The server listens on the port ",(0,o.kt)("inlineCode",{parentName:"p"},"3001")," .We can also write a middleware for protecting routes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"function proctectRoute(req,res,next){\n  // if user exists the token was sent with the request\n  if(req.user){\n   //if user exists then go to next middleware\n     next();\n  }\n// token was not sent with request send error to user\n  else{\n     res.status(500).json({error:'login is required'});\n  }\n}\n")),(0,o.kt)("p",null,"We can use different options with the JSON Web Tokens library. We can set the expiration time, subject, time of issue, etc."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// we can change algorithm used\njwt.sign({ foo: 'bar' }, cert,\n{ algorithm:'RS256'},function(err,token) {\n    console.log(token);\n});\n\n// we can set expiration time using sync\nconst token =jwt.sign({data: 'foobar'}, 'secret',\n { expiresIn: 60 * 60 });\n")),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"JSON Web Tokens are great for authentications and very easy to use. The tutorial shows us how we can use JWT for authentication using Node.js and Express."),(0,o.kt)("p",null,"JWT can also be used for different purposes, which includes any type of claim. The JWT used in the tutorial are signed using a symmetrical algorithm, but you can easily use asymmetrical algorithms also. In the asymmetrical algorithm, the private key is used to sign the token, and a public key is used for verifying the tokens."))}d.isMDXComponent=!0}}]);