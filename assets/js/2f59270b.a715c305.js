(self.webpackChunkanshulrgoyal=self.webpackChunkanshulrgoyal||[]).push([[8990],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,k=u["".concat(s,".").concat(d)]||u[d]||c[d]||i;return n?a.createElement(k,o(o({ref:t},m),{},{components:n})):a.createElement(k,o({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2992:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return m},default:function(){return u}});var a=n(2122),r=n(9756),i=(n(7294),n(3905)),o=["components"],l={slug:"macro-rust",title:"An intro to macros in rust",author:"Anshul Goyal",author_url:"https://github.com/anshulrgoyal",author_image_url:"/img/anshul.jpg",tags:["rust","macro"],image:"https://blog.logrocket.com/wp-content/uploads/2021/02/Screen-Shot-2021-02-02-at-10.39.25-AM.png"},s=void 0,p={permalink:"/anshulrgoyal/blog/macro-rust",source:"@site/blog/2021-02-04-macro-rust.md",title:"An intro to macros in rust",description:"Rust has an excellent support for macros. Macros are a way of writing code that writes other code, which is known as metaprogramming. Macros provide functionality similar to functions, without the runtime cost associated with functions. Since macros are expanded during the compile time so some compile-time costs are associated with macros. Macros in rust are very different from the ones used in C. Rust macros are applied to the token tree whereas C macros are text substitution.",date:"2021-02-04T00:00:00.000Z",formattedDate:"February 4, 2021",tags:[{label:"rust",permalink:"/anshulrgoyal/blog/tags/rust"},{label:"macro",permalink:"/anshulrgoyal/blog/tags/macro"}],readingTime:16.165,truncated:!0,prevItem:{title:"How to create a Deno plugin in Rust",permalink:"/anshulrgoyal/blog/deno-plugin"},nextItem:{title:"MLH Fellowship: A new way of learning",permalink:"/anshulrgoyal/blog/mlh-fellowship"}},m=[{value:"Creating Declarative Macros",id:"creating-declarative-macros",children:[]},{value:"Using Declarative Macros for more advanced parsing",id:"using-declarative-macros-for-more-advanced-parsing",children:[]},{value:"Limitation of Declarative Macros",id:"limitation-of-declarative-macros",children:[]},{value:"Types of Procedural Macros",id:"types-of-procedural-macros",children:[]},{value:"Attribute like macros",id:"attribute-like-macros",children:[]},{value:"Custom Derive Macros",id:"custom-derive-macros",children:[]},{value:"Function Like Macro",id:"function-like-macro",children:[]},{value:"Advantage of procedural macros",id:"advantage-of-procedural-macros",children:[]}],c={toc:m};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Rust has an excellent support for macros. Macros are a way of writing code that writes other code, which is known as metaprogramming. Macros provide functionality similar to functions, without the runtime cost associated with functions. Since macros are expanded during the compile time so some compile-time costs are associated with macros. Macros in rust are very different from the ones used in C. Rust macros are applied to the token tree whereas C macros are text substitution."),(0,i.kt)("h1",{id:"types-of-macros"},"Types of macros"),(0,i.kt)("p",null,"Rust has two types of macros:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"declarative macros")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"procedural macros"))),(0,i.kt)("h1",{id:"declarative-macros"},"Declarative Macros"),(0,i.kt)("p",null,"These macros are declared using ",(0,i.kt)("inlineCode",{parentName:"p"},"macro_rules!"),". Declarative macros are a bit less powerful but provide an easy to use interface for creating macros to remove duplicate code. One of the common declarative macro is ",(0,i.kt)("inlineCode",{parentName:"p"},"println!"),". Declarative macros provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," like an interface where on match the macro is replaced with code inside the matched arm."),(0,i.kt)("h2",{id:"creating-declarative-macros"},"Creating Declarative Macros"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// use macro_rules! <name of macro>{<Body>}\nmacro_rules! add{\n // macth like arm for macro\n    ($a:expr,$b:expr)=>{\n // macro expand to this code\n        {\n// $a and $b will be templated using the value/variable provided to macro\n            $a+$b\n        }\n    }\n}\n\nfn main(){\n // call to macro, $a=1 and $b=2\n    add!(1,2);\n}\n")),(0,i.kt)("p",null,"This code creates a macro to add two numbers. ",(0,i.kt)("inlineCode",{parentName:"p"},"macro_rules!"),' are used with the name of the macro "add" and the body of the macro. The macro doesn\u2019t add two numbers, it just replaces itself with the code to add two numbers. Each arm of macro takes an argument for functions and multiple types can be assigned to arguments. If the add function can also take a single argument then we add another arm.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"macro_rules! add{\n // first arm match add!(1,2), add!(2,3) etc\n    ($a:expr,$b:expr)=>{\n        {\n            $a+$b\n        }\n    };\n// Second arm macth add!(1), add!(2) etc\n    ($a:expr)=>{\n        {\n            $a\n        }\n    }\n}\n\nfn main(){\n// call the macro\n    let x=0;\n    add!(1,2);\n    add!(x);\n}\n")),(0,i.kt)("p",null,"There can be multiple branches in a single macro expanding to different code based on different arguments. Each branch can take multiple arguments starting with the ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," sign and followed by a token type."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"item"),": an item, like a function, struct, module, etc."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"block"),": a block (i.e. a block of statements and/or an expression, surrounded by braces)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"stmt"),": a statement"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pat"),": a pattern"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expr"),": an expression"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ty"),": a type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ident"),": an identifier"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"path"),": a path (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"foo"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"::std::mem::replace"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"transmute::<_, int>"),", \u2026)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"meta"),": a meta item; the things that go inside ",(0,i.kt)("inlineCode",{parentName:"li"},"#[...]")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"#![...]")," attributes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tt"),": a single token tree"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"vis"),": a possibly empty ",(0,i.kt)("em",{parentName:"li"},"Visibility")," qualifier")),(0,i.kt)("p",null,"In the example, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"$typ")," argument with token type ",(0,i.kt)("inlineCode",{parentName:"p"},"ty")," as a datatype like ",(0,i.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"u16")," etc. This macro converts to a particular type before adding the numbers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'macro_rules! add_as{\n// using a ty token type for macthing types passed to maccro\n    ($a:expr,$b:expr,$typ:ty)=>{\n        $a as $typ + $b as $typ\n    }\n}\n\nfn main(){\n    println!("{}",add_as!(0,2,u8));\n}\n')),(0,i.kt)("p",null,"Macros also support taking non fixed number of arguments. The operators are very similar to the regular expression. ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," is used for zero or more token types and ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," for zero or one argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'macro_rules! add_as{\n    (\n  // repeated block\n  $($a:expr)\n // seperator\n   ,\n// zero or more\n   *\n   )=>{\n       { \n   // to handle the case without any arguments\n   0\n   // block to be repeated\n   $(+$a)*\n     }\n    }\n}\n\nfn main(){\n    println!("{}",add_as!(1,2,3,4)); // => println!("{}",{0+1+2+3+4})\n}\n')),(0,i.kt)("p",null,"The token type that repeats is enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"$()")," followed by a separator and a ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," indicating the number of times the token will repeat. The separator is used to distinguish the token from each other. ",(0,i.kt)("inlineCode",{parentName:"p"},"$()")," block followed by ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," is used to indicate the repeating block of code. In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"+$a")," is a repeating code."),(0,i.kt)("p",null,"If you look closely, you will notice an additional zero is added to the code to make the syntax valid. To remove this zero and make the add expression the same as the argument, we need to create a new macro known as TT muncher."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'macro_rules! add{\n // first arm in case of single argument and last remaining variable/number\n    ($a:expr)=>{\n        $a\n    };\n// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments\n    ($a:expr,$b:expr)=>{\n        {\n            $a+$b\n        }\n    };\n// add the number and the result of remaining arguments \n    ($a:expr,$($b:tt)*)=>{\n       {\n           $a+add!($($b)*)\n       }\n    }\n}\n\nfn main(){\n    println!("{}",add!(1,2,3,4));\n}\n')),(0,i.kt)("p",null,"The TT muncher processes each token separately in a recursive fashion. It is easier to process a single token at a time. The macro has three arms. The first arms handle the case when a single argument is passed, the second one handles the case when two arguments are passed and the third arm calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," macro again with the rest of the arguments."),(0,i.kt)("p",null,"The macro arguments don\u2019t need to be comma-separated. Multiple tokens can be used with different token types. For eg., brackets can be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"ident")," token type. The Rust compiler will take the matched arm and extract the variable from the argument string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'macro_rules! ok_or_return{\n// match something(q,r,t,6,7,8) etc\n// compiler extracts function name and arguments. It injects the values in respective varibles.\n    ($a:ident($($b:tt)*))=>{\n       {\n        match $a($($b)*) {\n            Ok(value)=>value,\n            Err(err)=>{\n                return Err(err);\n            }\n        }\n        }\n    };\n}\n\nfn some_work(i:i64,j:i64)->Result<(i64,i64),String>{\n    if i+j>2 {\n        Ok((i,j))\n    } else {\n        Err("error".to_owned())\n    }\n}\n\nfn main()->Result<(),String>{\n    ok_or_return!(some_work(1,4));\n    ok_or_return!(some_work(1,0));\n    Ok(())\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ok_or_return")," macro returns the function if an operation returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Err")," or the value of an operation returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok"),". It takes a function as an argument and executes it inside a match statement. For arguments passed to function, it uses repetition."),(0,i.kt)("p",null,"Sometimes few macros need to be grouped into a single macro. In that case, internal macro rules are used. It helps to manipulate the macro inputs and write clean TT munchers. For creating an internal rule, add the rule name starting with ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," as the argument. Now the macro will never match for an internal rule until explicitly specified as an argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'macro_rules! ok_or_return{\n // internal rule.\n    (@error $a:ident,$($b:tt)* )=>{\n        {\n        match $a($($b)*) {\n            Ok(value)=>value,\n            Err(err)=>{\n                return Err(err);\n            }\n        }\n        }\n    };\n\n// public rule can be called by the user.\n    ($a:ident($($b:tt)*))=>{\n        ok_or_return!(@error $a,$($b)*)\n    };\n}\n\nfn some_work(i:i64,j:i64)->Result<(i64,i64),String>{\n    if i+j>2 {\n        Ok((i,j))\n    } else {\n        Err("error".to_owned())\n    }\n}\n\nfn main()->Result<(),String>{\n   // instead of round bracket curly brackets can also be used\n    ok_or_return!{some_work(1,4)};\n    ok_or_return!(some_work(1,0));\n    Ok(())\n}\n')),(0,i.kt)("h2",{id:"using-declarative-macros-for-more-advanced-parsing"},"Using Declarative Macros for more advanced parsing"),(0,i.kt)("p",null,"Often macros perform some task that requires parsing of rust language itself. Let's create a macro that makes struct public by suffixing the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," keyword. It will sum up all the knowledge we have gathered until now in this article."),(0,i.kt)("p",null,"First, we need to parse the rust struct to get the name of the struct, fields of the struct, and field type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parsing the name and field of struct"),"\nA ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," declaration has a visibility keyword at the start (like ",(0,i.kt)("inlineCode",{parentName:"p"},"pub"),") followed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," keyword and then the name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," and the body of the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_FF6F5912049FBF771235F34EC177AEC60D1A4D88404944221274BA302586323D_1609351688370_Struct.png",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"macro_rules! make_public{\n    (\n  // use vis type for visibility keyword and ident for struct name\n     $vis:vis struct $struct_name:ident { }\n    ) => {\n        {\n            pub struct $struct_name{ }\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"$vis")," will have visibility and ",(0,i.kt)("inlineCode",{parentName:"p"},"$struct_name")," will have a struct name. For making a struct public, we just need to add the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," keyword and ignore the ",(0,i.kt)("inlineCode",{parentName:"p"},"$vis")," variable."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://paper-attachments.dropbox.com/s_FF6F5912049FBF771235F34EC177AEC60D1A4D88404944221274BA302586323D_1609357470638_Struct4.png",alt:null})),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," may contain multiple fields with the same or different data types and visibility. ",(0,i.kt)("inlineCode",{parentName:"p"},"ty")," token type is used for the data type, ",(0,i.kt)("inlineCode",{parentName:"p"},"vis")," for visibility, and ",(0,i.kt)("inlineCode",{parentName:"p"},"ident")," for the field name. We will use ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," repetition for zero or more fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"}," macro_rules! make_public{\n    (\n     $vis:vis struct $struct_name:ident {\n        $(\n // vis for field visibility, ident for field name and ty for field data type\n        $field_vis:vis $field_name:ident : $field_type:ty\n        ),*\n    }\n    ) => {\n        {\n            pub struct $struct_name{\n                $(\n                pub $field_name : $field_type,\n                )*\n            }\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parsing Metadata from the")," ",(0,i.kt)("inlineCode",{parentName:"p"},"**struct**")),(0,i.kt)("p",null,"Often the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," has some metadata attached or procedural macros like ",(0,i.kt)("inlineCode",{parentName:"p"},"#[derive(Debug)]"),". This metadata needs to stay intact. So parsing this metadata is done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"macro_rules! make_public{\n    (\n     // meta data about struct\n     $(#[$meta:meta])* \n     $vis:vis struct $struct_name:ident {\n        $(\n        // meta data about field\n        $(#[$field_meta:meta])*\n        $field_vis:vis $field_name:ident : $field_type:ty\n        ),*$(,)+\n    }\n    ) => {\n        { \n            $(#[$meta])*\n            pub struct $struct_name{\n                $(\n                $(#[$field_meta:meta])*\n                pub $field_name : $field_type,\n                )*\n            }\n        }\n    }\n}\n")),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"make_public")," macro is ready now. To see how ",(0,i.kt)("inlineCode",{parentName:"p"},"make_public")," works let's use ",(0,i.kt)("a",{parentName:"p",href:"https://play.rust-lang.org/"},"Rust Playground")," to expand the macro to the actual code that is compiled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"macro_rules! make_public{\n    (\n     $(#[$meta:meta])* \n     $vis:vis struct $struct_name:ident {\n        $(\n        $(#[$field_meta:meta])*\n        $field_vis:vis $field_name:ident : $field_type:ty\n        ),*$(,)+\n    }\n    ) => {\n\n            $(#[$meta])*\n            pub struct $struct_name{\n                $(\n                $(#[$field_meta:meta])*\n                pub $field_name : $field_type,\n                )*\n            }\n    }\n}\n\nfn main(){\n    make_public!{\n        #[derive(Debug)]\n        struct Name{\n            n:i64,\n            t:i64,\n            g:i64,\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The expanded code looks like this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// some imports\n\n\nmacro_rules! make_public {\n    ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident\n     {\n         $\n         ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident\n          : $ field_type : ty), * $ (,) +\n     }) =>\n    {\n\n            $ (#[$ meta]) * pub struct $ struct_name\n            {\n                $\n                ($ (#[$ field_meta : meta]) * pub $ field_name : $\n                 field_type,) *\n            }\n    }\n}\n\nfn main() {\n        pub struct name {\n            pub n: i64,\n            pub t: i64,\n            pub g: i64,\n    }\n}\n")),(0,i.kt)("h2",{id:"limitation-of-declarative-macros"},"Limitation of Declarative Macros"),(0,i.kt)("p",null,"Declarative Macros have a few limitations. Some are related to macros themselves others are more specific to Declarative Macros."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Most IDEs don\u2019t have good support for macros auto-completion and expansion."),(0,i.kt)("li",{parentName:"ol"},"Debugging declarative macros is difficult."),(0,i.kt)("li",{parentName:"ol"},"Limited modification capability of declarative macros."),(0,i.kt)("li",{parentName:"ol"},"Macros can result in larger binaries."),(0,i.kt)("li",{parentName:"ol"},"Longer compile time.")),(0,i.kt)("h1",{id:"procedural-macros"},"Procedural Macros"),(0,i.kt)("p",null,"Procedural macros are a more advanced version of macros. Procedural macros allow expanding the existing syntax of rust. It takes arbitrary input and returns valid rust code.\nThe procedural macros are functions that take a ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream")," as input and return another ",(0,i.kt)("inlineCode",{parentName:"p"},"T``oken``Stream"),". The procedural macros manipulate the input ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream")," to produce an output stream."),(0,i.kt)("h2",{id:"types-of-procedural-macros"},"Types of Procedural Macros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Attribute like macros"),(0,i.kt)("li",{parentName:"ul"},"Derive macros"),(0,i.kt)("li",{parentName:"ul"},"Function like macros")),(0,i.kt)("h2",{id:"attribute-like-macros"},"Attribute like macros"),(0,i.kt)("p",null,"An attribute like macros allows the creating of a custom attribute that attaches itself to an Item and allows manipulation of that Item. It can also take arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[some_attribute_macro(some_argument)]\nfn perform_task(){\n// some code\n}\n")),(0,i.kt)("p",null,"In the above code, ",(0,i.kt)("inlineCode",{parentName:"p"},"some_attribute_macros")," is an attribute macro. It manipulates the function ",(0,i.kt)("inlineCode",{parentName:"p"},"perform_task"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Writing attribute like macro"),"\nStart by creating a project using ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo new macro-demo")," ",(0,i.kt)("inlineCode",{parentName:"p"},"--``lib"),". Once the project is ready to update the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," to notify cargo the project will create procedural macros."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# Cargo.toml\n[lib]\nproc-macro = true\n")),(0,i.kt)("p",null,"Now we are all set to venture into procedural macros."),(0,i.kt)("p",null,"Procedural macros are public functions that take ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream")," as input and return another ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream"),". For writing procedural macro, we need to write our parser to parse ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream"),". Rust community has a very good crate ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," for parsing ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"syn")," provides a ready-made parser for Rustlang syntax that can be used to parse ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream"),". You can also parse your syntax by combining low-level parsers providing ",(0,i.kt)("inlineCode",{parentName:"p"},"syn"),"."),(0,i.kt)("p",null,"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"quote")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# Cargo.toml\n[dependencies]\nsyn = {version="1.0.57",features=["full","fold"]}\nquote = "1.0.8"\n')),(0,i.kt)("p",null,"Now we can write an attribute like a macro in ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"proc_macro")," crate provided by the compiler for writing procedural macros. A procedural macro crate cannot export anything else other than procedural macros and procedural macros defined in the crate can\u2019t be used in the crate itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// lib.rs\nextern crate proc_macro;\nuse proc_macro::{TokenStream};\nuse quote::{quote};\n\n// using proc_macro_attribute to declare an attribute like procedural macro\n#[proc_macro_attribute]\n// _metadata is argument provided to macro call and _input is code to which attribute like macro attaches\npub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -> TokenStream {\n    // returing a simple TokenStream for Struct\n    TokenStream::from(quote!{struct H{}})\n}\n")),(0,i.kt)("p",null,"To test the macro we added, create an ingratiation test by creating a folder named ",(0,i.kt)("inlineCode",{parentName:"p"},"tests")," and adding file ",(0,i.kt)("inlineCode",{parentName:"p"},"attribute_macro.rs")," in the folder. Now in this file, we can use our attribute like a macro for testing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// tests/attribute_macro.rs\n\nuse macro_demo::*;\n\n// macro converts struct S to struct H\n#[my_custom_attribute]\nstruct S{}\n\n#[test]\nfn test_macro(){\n// due to macro we have struct H in scope\n    let demo=H{};\n}\n")),(0,i.kt)("p",null,"Run the above test using the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo test")," command.\nNow that we have some knowledge of procedural macros, lets use ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," for some advance ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream")," manipulation and parsing."),(0,i.kt)("p",null,"For learning how ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," is used for parsing and manipulation, let's take an example of ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs"},"repo"),". This example creates a macro that trace variables when value changes."),(0,i.kt)("p",null,"First, we need to identify how our macro will manipulate the code it attaches."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[trace_vars(a)]\nfn do_something(){\n  let a=9;\n  a=6;\n  a=0;\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"trace_vars")," macro takes the name of the variable it needs to trace and injects a print statement each time the value of the input variable i.e ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," changes. It tracks the value of input variables."),(0,i.kt)("p",null,"First, parse the code to which the attribute like macro attaches. ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," provides an inbuilt parser for Rust function syntax. ",(0,i.kt)("inlineCode",{parentName:"p"},"ItemFn")," will parse the function and throw an error if the syntax is invalid."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[proc_macro_attribute]\npub fn trace_vars(_metadata: TokenStream, input: TokenStream) -> TokenStream {\n// parsing rust function to easy to use struct\n    let input_fn = parse_macro_input!(input as ItemFn);\n    TokenStream::from(quote!{fn dummy(){}})\n}\n")),(0,i.kt)("p",null,"Now we have the parsed ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," so let's move to ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata"),". For ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata")," , no inbuilt parser will work, we will have to write one ourselves for it, using ",(0,i.kt)("inlineCode",{parentName:"p"},"syn"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"parse")," module."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#[trace_vars(a,c,b)] // we need to parse a "," seperated list of tokens\n// code\n')),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," to work, we need to implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse")," trait provided by ",(0,i.kt)("inlineCode",{parentName:"p"},"syn"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Punctuated")," is used to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"vector")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Indent")," separated by ",(0,i.kt)("inlineCode",{parentName:"p"},","),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"struct Args{\n    vars:HashSet<Ident>\n}\n\nimpl Parse for Args{\n    fn parse(input: ParseStream) -> Result<Self> {\n        // parses a,b,c, or a,b,c where a,b and c are Indent\n        let vars = Punctuated::<Ident, Token![,]>::parse_terminated(input)?;\n        Ok(Args {\n            vars: vars.into_iter().collect(),\n        })\n    }\n}\n")),(0,i.kt)("p",null,"Once we implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse")," trait we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"parse_macro_input")," macro for parsing ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[proc_macro_attribute]\npub fn trace_vars(metadata: TokenStream, input: TokenStream) -> TokenStream {\n    let input_fn = parse_macro_input!(input as ItemFn);\n// using newly created struct Args\n    let args= parse_macro_input!(metadata as Args);\n    TokenStream::from(quote!{fn dummy(){}})\n}\n")),(0,i.kt)("p",null,"We will now modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"input_fn")," to add ",(0,i.kt)("inlineCode",{parentName:"p"},"println!")," when the variable changes the value. For adding, we need to filter outlines that have an assignment and insert a print statement after that line."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'impl Args {\n    fn should_print_expr(&self, e: &Expr) -> bool {\n        match *e {\n            Expr::Path(ref e) => {\n // variable shouldn\'t start wiht ::\n                if e.path.leading_colon.is_some() {\n                    false\n// should be a single variable like `x=8` not n::x=0 \n                } else if e.path.segments.len() != 1 {\n                    false\n                } else {\n// get the first part\n                    let first = e.path.segments.first().unwrap();\n// check if the variable name is in the Args.vars hashset\n                    self.vars.contains(&first.ident) && first.arguments.is_empty()\n                }\n            }\n            _ => false,\n        }\n    }\n\n// used for checking if to print let i=0 etc or not\n    fn should_print_pat(&self, p: &Pat) -> bool {\n        match p {\n// check if variable name is present in set\n            Pat::Ident(ref p) => self.vars.contains(&p.ident),\n            _ => false,\n        }\n    }\n\n// manipulate tree to insert print statement\n    fn assign_and_print(&mut self, left: Expr, op: &dyn ToTokens, right: Expr) -> Expr {\n // recurive call on right of the assigment statement\n        let right = fold::fold_expr(self, right);\n// returning manipulated sub-tree\n        parse_quote!({\n            #left #op #right;\n            println!(concat!(stringify!(#left), " = {:?}"), #left);\n        })\n    }\n\n// manipulating let statement\n    fn let_and_print(&mut self, local: Local) -> Stmt {\n        let Local { pat, init, .. } = local;\n        let init = self.fold_expr(*init.unwrap().1);\n// get the variable name of assigned variable\n        let ident = match pat {\n            Pat::Ident(ref p) => &p.ident,\n            _ => unreachable!(),\n        };\n// new sub tree\n        parse_quote! {\n            let #pat = {\n                #[allow(unused_mut)]\n                let #pat = #init;\n                println!(concat!(stringify!(#ident), " = {:?}"), #ident);\n                #ident\n            };\n        }\n    }\n}\n')),(0,i.kt)("p",null,"In the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"quote")," macro is used for template and writing Rust. ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," is used for injecting the value of the variable."),(0,i.kt)("p",null,"Now we will do a DFS over ",(0,i.kt)("inlineCode",{parentName:"p"},"input_fn")," and insert the print statement. ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"Fold")," trait that can be implemented for DFS over any ",(0,i.kt)("inlineCode",{parentName:"p"},"Item"),". We just need to modify the trait methods corresponding to the Token type we want to manipulate."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl Fold for Args {\n    fn fold_expr(&mut self, e: Expr) -> Expr {\n        match e {\n// for changing assignment like a=5\n            Expr::Assign(e) => {\n// check should print\n                if self.should_print_expr(&e.left) {\n                    self.assign_and_print(*e.left, &e.eq_token, *e.right)\n                } else {\n// continue with default travesal using default methods\n                    Expr::Assign(fold::fold_expr_assign(self, e))\n                }\n            }\n// for changing assigment and operation like a+=1\n            Expr::AssignOp(e) => {\n// check should print\n                if self.should_print_expr(&e.left) {\n                    self.assign_and_print(*e.left, &e.op, *e.right)\n                } else {\n// continue with default behaviour\n                    Expr::AssignOp(fold::fold_expr_assign_op(self, e))\n                }\n            }\n// continue with default behaviour for rest of expressions\n            _ => fold::fold_expr(self, e),\n        }\n    }\n\n// for let statements like let d=9\n    fn fold_stmt(&mut self, s: Stmt) -> Stmt {\n        match s {\n            Stmt::Local(s) => {\n                if s.init.is_some() && self.should_print_pat(&s.pat) {\n                    self.let_and_print(s)\n                } else {\n                    Stmt::Local(fold::fold_local(self, s))\n                }\n            }\n            _ => fold::fold_stmt(self, s),\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Fold")," trait is used to do a DFS of ",(0,i.kt)("inlineCode",{parentName:"p"},"Item"),". It allows using different behavior for various Token types.\nNow we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_item_fn")," to inject print statements in our parsed code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[proc_macro_attribute]\npub fn trace_var(args: TokenStream, input: TokenStream) -> TokenStream {\n// parse the input\n    let input = parse_macro_input!(input as ItemFn);\n// parse the arguments\n    let mut args = parse_macro_input!(args as Args);\n// create the ouput\n    let output = args.fold_item_fn(input);\n// return the TokenStream\n    TokenStream::from(quote!(#output))\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note: This code example is from")," ",(0,i.kt)("inlineCode",{parentName:"p"},"***syn***")," ",(0,i.kt)("strong",{parentName:"p"},"**"),(0,i.kt)("a",{parentName:"p",href:"https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs"},(0,i.kt)("strong",{parentName:"a"},(0,i.kt)("em",{parentName:"strong"},"examples"))),(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},". It is a very good resource to learn about procedural macros."))),(0,i.kt)("h2",{id:"custom-derive-macros"},"Custom Derive Macros"),(0,i.kt)("p",null,"Custom derive macros allow auto implement traits. These macro allow to implement trait using ",(0,i.kt)("inlineCode",{parentName:"p"},"#[derive(Trait)]"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," has excellent support for ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," macros."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[derive(Trait)]\nstruct MyStruct{}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Writing Custom Derive Macros"),"\nWe will use ",(0,i.kt)("inlineCode",{parentName:"p"},"DeriveInput")," for parsing input to derive macro. We will also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"proc_macro_derive")," macro for defining a custom derive macro."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#[proc_macro_derive(Trait)]\npub fn derive_trait(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n\n    let name = input.ident;\n\n    let expanded = quote! {\n        impl Trait for #name {\n            fn print(&self) -> usize {\n                println!("{}","hello from #name")\n           }\n        }\n    };\n\n    proc_macro::TokenStream::from(expanded)\n}\n')),(0,i.kt)("p",null,"More advanced procedural macros can be written using ",(0,i.kt)("inlineCode",{parentName:"p"},"syn")," check out this example from ",(0,i.kt)("inlineCode",{parentName:"p"},"syn"),"'s ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs"},"repo.")),(0,i.kt)("h2",{id:"function-like-macro"},"Function Like Macro"),(0,i.kt)("p",null,"Function-like macros are similar to declarative macros in the way that they are invoked with the macro invocation operator ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," and look like function calls. They operate on the code that is inside the parentheses."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Writing Function like macro")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#[proc_macro]\npub fn a_proc_macro(_input: TokenStream) -> TokenStream {\n    TokenStream::from(quote!(\n            fn anwser()->i32{\n                5\n            }\n))\n}\n")),(0,i.kt)("p",null,"Functions like macro are not executed at runtime but at compile time. It can be used anywhere in code. It also takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream")," and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"TokenStream"),"."),(0,i.kt)("h2",{id:"advantage-of-procedural-macros"},"Advantage of procedural macros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Better error handling using ",(0,i.kt)("inlineCode",{parentName:"li"},"span")),(0,i.kt)("li",{parentName:"ul"},"Good control over output"),(0,i.kt)("li",{parentName:"ul"},"Good community built crates ",(0,i.kt)("inlineCode",{parentName:"li"},"syn")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"quote")),(0,i.kt)("li",{parentName:"ul"},"It is more powerful than declarative macros.")),(0,i.kt)("h1",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this piece, we learned about macros and different types of macros with the basics of writing both types of macros using various syntax and community built crates. We also learned the advantage of each type of macros."))}u.isMDXComponent=!0}}]);