<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/anshulrgoyal/blog/rss.xml" title="Anshul Goyal Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/anshulrgoyal/blog/atom.xml" title="Anshul Goyal Blog Atom Feed"><title data-react-helmet="true">An intro to macros in rust | Anshul Goyal</title><meta data-react-helmet="true" property="og:title" content="An intro to macros in rust | Anshul Goyal"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="description" content="Rust has an excellent support for macros. Macros are a way of writing code that writes other code, which is known as metaprogramming. Macros provide functionality similar to functions, without the runtime cost associated with functions. Since macros are expanded during the compile time so some compile-time costs are associated with macros. Macros in rust are very different from the ones used in C. Rust macros are applied to the token tree whereas C macros are text substitution."><meta data-react-helmet="true" property="og:description" content="Rust has an excellent support for macros. Macros are a way of writing code that writes other code, which is known as metaprogramming. Macros provide functionality similar to functions, without the runtime cost associated with functions. Since macros are expanded during the compile time so some compile-time costs are associated with macros. Macros in rust are very different from the ones used in C. Rust macros are applied to the token tree whereas C macros are text substitution."><meta data-react-helmet="true" property="og:url" content="https://anshulrgoyal.github.io/anshulrgoyal/blog/macro-rust"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:image" content="https://blog.logrocket.com/wp-content/uploads/2021/02/Screen-Shot-2021-02-02-at-10.39.25-AM.png"><meta data-react-helmet="true" name="twitter:image" content="https://blog.logrocket.com/wp-content/uploads/2021/02/Screen-Shot-2021-02-02-at-10.39.25-AM.png"><link data-react-helmet="true" rel="shortcut icon" href="/anshulrgoyal/img/anshul.jpg"><link data-react-helmet="true" rel="canonical" href="https://anshulrgoyal.github.io/anshulrgoyal/blog/macro-rust"><link data-react-helmet="true" rel="alternate" href="https://anshulrgoyal.github.io/anshulrgoyal/blog/macro-rust" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://anshulrgoyal.github.io/anshulrgoyal/blog/macro-rust" hreflang="x-default"><link rel="stylesheet" href="/anshulrgoyal/assets/css/styles.056d3a92.css">
<link rel="preload" href="/anshulrgoyal/assets/js/runtime~main.113fc30b.js" as="script">
<link rel="preload" href="/anshulrgoyal/assets/js/main.56fd1749.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><div class="announcementBar_3WsW" role="banner"><div class="announcementBarContent_3EUC announcementBarCloseable_3myR">I am looking for a JOB.</div><button type="button" class="announcementBarClose_38nx clean-btn" aria-label="Close"><span aria-hidden="true">Ã—</span></button></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/anshulrgoyal/"><b class="navbar__title">Anshul Goyal</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/anshulrgoyal/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/anshulrgoyal/projects">Conributions</a><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/anshulrgoyal/"><b class="navbar__title">Anshul Goyal</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/anshulrgoyal/projects">Conributions</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/anshulrgoyal/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/anshulrgoyal/blog/deno-plugin">How to create a Deno plugin in Rust</a></li><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/anshulrgoyal/blog/macro-rust">An intro to macros in rust</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/anshulrgoyal/blog/mlh-fellowship">MLH Fellowship: A new way of learning</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/anshulrgoyal/blog/easy-documentation-docusaurus">Easy Documentation using Docusaurus</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/anshulrgoyal/blog/rust-auth-lib">The state of Rust: Authorization/authentication libraries</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="blogPostTitle_GeHD">An intro to macros in rust</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2021-02-04T00:00:00.000Z">February 4, 2021</time> Â· 17 min read</div><div class="avatar margin-vert--md"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="/img/anshul.jpg" alt="Anshul Goyal"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer">Anshul Goyal</a></div><small class="avatar__subtitle"></small></div></div></header><div class="markdown"><p>Rust has an excellent support for macros. Macros are a way of writing code that writes other code, which is known as metaprogramming. Macros provide functionality similar to functions, without the runtime cost associated with functions. Since macros are expanded during the compile time so some compile-time costs are associated with macros. Macros in rust are very different from the ones used in C. Rust macros are applied to the token tree whereas C macros are text substitution.</p><header><h1 class="h1Heading_27L5">Types of macros</h1></header><p>Rust has two types of macros:</p><ul><li><em>declarative macros</em></li><li><em>procedural macros</em></li></ul><header><h1 class="h1Heading_27L5">Declarative Macros</h1></header><p>These macros are declared using <code>macro_rules!</code>. Declarative macros are a bit less powerful but provide an easy to use interface for creating macros to remove duplicate code. One of the common declarative macro is <code>println!</code>. Declarative macros provide a <code>match</code> like an interface where on match the macro is replaced with code inside the matched arm.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="creating-declarative-macros"></a>Creating Declarative Macros<a class="hash-link" href="#creating-declarative-macros" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// use macro_rules! &lt;name of macro&gt;{&lt;Body&gt;}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! add{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // macth like arm for macro</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr,$b:expr)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // macro expand to this code</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// $a and $b will be templated using the value/variable provided to macro</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $a+$b</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // call to macro, $a=1 and $b=2</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    add!(1,2);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This code creates a macro to add two numbers. <code>macro_rules!</code> are used with the name of the macro &quot;add&quot; and the body of the macro. The macro doesnâ€™t add two numbers, it just replaces itself with the code to add two numbers. Each arm of macro takes an argument for functions and multiple types can be assigned to arguments. If the add function can also take a single argument then we add another arm.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! add{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // first arm match add!(1,2), add!(2,3) etc</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr,$b:expr)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $a+$b</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// Second arm macth add!(1), add!(2) etc</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $a</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// call the macro</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let x=0;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    add!(1,2);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    add!(x);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>There can be multiple branches in a single macro expanding to different code based on different arguments. Each branch can take multiple arguments starting with the <code>$</code> sign and followed by a token type.</p><ul><li><code>item</code>: an item, like a function, struct, module, etc.</li><li><code>block</code>: a block (i.e. a block of statements and/or an expression, surrounded by braces)</li><li><code>stmt</code>: a statement</li><li><code>pat</code>: a pattern</li><li><code>expr</code>: an expression</li><li><code>ty</code>: a type</li><li><code>ident</code>: an identifier</li><li><code>path</code>: a path (e.g. <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, â€¦)</li><li><code>meta</code>: a meta item; the things that go inside <code>#[...]</code> and <code>#![...]</code> attributes</li><li><code>tt</code>: a single token tree</li><li><code>vis</code>: a possibly empty <em>Visibility</em> qualifier</li></ul><p>In the example, we use the <code>$typ</code> argument with token type <code>ty</code> as a datatype like <code>u8</code>, <code>u16</code> etc. This macro converts to a particular type before adding the numbers.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! add_as{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// using a ty token type for macthing types passed to maccro</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr,$b:expr,$typ:ty)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $a as $typ + $b as $typ</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;{}&quot;,add_as!(0,2,u8));</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Macros also support taking non fixed number of arguments. The operators are very similar to the regular expression. <code>*</code> is used for zero or more token types and <code>+</code> for zero or one argument.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! add_as{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // repeated block</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  $($a:expr)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // seperator</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   ,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// zero or more</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   *</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   )=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       { </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   // to handle the case without any arguments</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   0</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   // block to be repeated</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   $(+$a)*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;{}&quot;,add_as!(1,2,3,4)); // =&gt; println!(&quot;{}&quot;,{0+1+2+3+4})</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The token type that repeats is enclosed in <code>$()</code> followed by a separator and a <code>*</code> or <code>+</code> indicating the number of times the token will repeat. The separator is used to distinguish the token from each other. <code>$()</code> block followed by <code>*</code> or <code>+</code> is used to indicate the repeating block of code. In the above example, <code>+$a</code> is a repeating code.</p><p>If you look closely, you will notice an additional zero is added to the code to make the syntax valid. To remove this zero and make the add expression the same as the argument, we need to create a new macro known as TT muncher.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! add{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // first arm in case of single argument and last remaining variable/number</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $a</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr,$b:expr)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $a+$b</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// add the number and the result of remaining arguments </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:expr,$($b:tt)*)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">           $a+add!($($b)*)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;{}&quot;,add!(1,2,3,4));</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The TT muncher processes each token separately in a recursive fashion. It is easier to process a single token at a time. The macro has three arms. The first arms handle the case when a single argument is passed, the second one handles the case when two arguments are passed and the third arm calls the <code>add</code> macro again with the rest of the arguments.</p><p>The macro arguments donâ€™t need to be comma-separated. Multiple tokens can be used with different token types. For eg., brackets can be used with <code>ident</code> token type. The Rust compiler will take the matched arm and extract the variable from the argument string.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! ok_or_return{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// match something(q,r,t,6,7,8) etc</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// compiler extracts function name and arguments. It injects the values in respective varibles.</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:ident($($b:tt)*))=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">       {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match $a($($b)*) {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Ok(value)=&gt;value,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Err(err)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                return Err(err);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if i+j&gt;2 {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Ok((i,j))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Err(&quot;error&quot;.to_owned())</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main()-&gt;Result&lt;(),String&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ok_or_return!(some_work(1,4));</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ok_or_return!(some_work(1,0));</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>ok_or_return</code> macro returns the function if an operation returns <code>Err</code> or the value of an operation returns <code>Ok</code>. It takes a function as an argument and executes it inside a match statement. For arguments passed to function, it uses repetition.</p><p>Sometimes few macros need to be grouped into a single macro. In that case, internal macro rules are used. It helps to manipulate the macro inputs and write clean TT munchers. For creating an internal rule, add the rule name starting with <code>@</code> as the argument. Now the macro will never match for an internal rule until explicitly specified as an argument.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! ok_or_return{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // internal rule.</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (@error $a:ident,$($b:tt)* )=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match $a($($b)*) {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Ok(value)=&gt;value,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Err(err)=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                return Err(err);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// public rule can be called by the user.</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($a:ident($($b:tt)*))=&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ok_or_return!(@error $a,$($b)*)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if i+j&gt;2 {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Ok((i,j))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Err(&quot;error&quot;.to_owned())</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main()-&gt;Result&lt;(),String&gt;{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   // instead of round bracket curly brackets can also be used</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ok_or_return!{some_work(1,4)};</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ok_or_return!(some_work(1,0));</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="using-declarative-macros-for-more-advanced-parsing"></a>Using Declarative Macros for more advanced parsing<a class="hash-link" href="#using-declarative-macros-for-more-advanced-parsing" title="Direct link to heading">#</a></h2><p>Often macros perform some task that requires parsing of rust language itself. Let&#x27;s create a macro that makes struct public by suffixing the <code>pub</code> keyword. It will sum up all the knowledge we have gathered until now in this article.</p><p>First, we need to parse the rust struct to get the name of the struct, fields of the struct, and field type.</p><p><strong>Parsing the name and field of struct</strong>
A <code>struct</code> declaration has a visibility keyword at the start (like <code>pub</code>) followed by the <code>struct</code> keyword and then the name of the <code>struct</code> and the body of the <code>struct</code>.</p><p><img src="https://paper-attachments.dropbox.com/s_FF6F5912049FBF771235F34EC177AEC60D1A4D88404944221274BA302586323D_1609351688370_Struct.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! make_public{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // use vis type for visibility keyword and ident for struct name</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $vis:vis struct $struct_name:ident { }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub struct $struct_name{ }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>$vis</code> will have visibility and <code>$struct_name</code> will have a struct name. For making a struct public, we just need to add the <code>pub</code> keyword and ignore the <code>$vis</code> variable.</p><p><img src="https://paper-attachments.dropbox.com/s_FF6F5912049FBF771235F34EC177AEC60D1A4D88404944221274BA302586323D_1609357470638_Struct4.png"></p><p>A <code>struct</code> may contain multiple fields with the same or different data types and visibility. <code>ty</code> token type is used for the data type, <code>vis</code> for visibility, and <code>ident</code> for the field name. We will use <code>*</code> repetition for zero or more fields.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain"> macro_rules! make_public{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $vis:vis struct $struct_name:ident {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // vis for field visibility, ident for field name and ty for field data type</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $field_vis:vis $field_name:ident : $field_type:ty</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ),*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub struct $struct_name{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                pub $field_name : $field_type,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                )*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>Parsing Metadata from the</strong> <code>**struct**</code></p><p>Often the <code>struct</code> has some metadata attached or procedural macros like <code>#[derive(Debug)]</code>. This metadata needs to stay intact. So parsing this metadata is done using the <code>meta</code> type.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! make_public{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     // meta data about struct</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $(#[$meta:meta])* </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $vis:vis struct $struct_name:ident {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // meta data about field</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $(#[$field_meta:meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $field_vis:vis $field_name:ident : $field_type:ty</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ),*$(,)+</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        { </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $(#[$meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub struct $struct_name{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $(#[$field_meta:meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                pub $field_name : $field_type,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                )*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Our <code>make_public</code> macro is ready now. To see how <code>make_public</code> works let&#x27;s use <a href="https://play.rust-lang.org/" target="_blank" rel="noopener noreferrer">Rust Playground</a> to expand the macro to the actual code that is compiled.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! make_public{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $(#[$meta:meta])* </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     $vis:vis struct $struct_name:ident {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $(#[$field_meta:meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        $field_vis:vis $field_name:ident : $field_type:ty</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ),*$(,)+</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $(#[$meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub struct $struct_name{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $(#[$field_meta:meta])*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                pub $field_name : $field_type,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                )*</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    make_public!{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        #[derive(Debug)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        struct Name{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            n:i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            t:i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            g:i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The expanded code looks like this.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// some imports</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">macro_rules! make_public {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         $</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">         ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">          : $ field_type : ty), * $ (,) +</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     }) =&gt;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            $ (#[$ meta]) * pub struct $ struct_name</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                $</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                ($ (#[$ field_meta : meta]) * pub $ field_name : $</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                 field_type,) *</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        pub struct name {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub n: i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub t: i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            pub g: i64,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="limitation-of-declarative-macros"></a>Limitation of Declarative Macros<a class="hash-link" href="#limitation-of-declarative-macros" title="Direct link to heading">#</a></h2><p>Declarative Macros have a few limitations. Some are related to macros themselves others are more specific to Declarative Macros.</p><ol><li>Most IDEs donâ€™t have good support for macros auto-completion and expansion.</li><li>Debugging declarative macros is difficult.</li><li>Limited modification capability of declarative macros.</li><li>Macros can result in larger binaries.</li><li>Longer compile time.</li></ol><header><h1 class="h1Heading_27L5">Procedural Macros</h1></header><p>Procedural macros are a more advanced version of macros. Procedural macros allow expanding the existing syntax of rust. It takes arbitrary input and returns valid rust code.
The procedural macros are functions that take a <code>TokenStream</code> as input and return another <code>T``oken``Stream</code>. The procedural macros manipulate the input <code>TokenStream</code> to produce an output stream.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="types-of-procedural-macros"></a>Types of Procedural Macros<a class="hash-link" href="#types-of-procedural-macros" title="Direct link to heading">#</a></h2><ul><li>Attribute like macros</li><li>Derive macros</li><li>Function like macros</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="attribute-like-macros"></a>Attribute like macros<a class="hash-link" href="#attribute-like-macros" title="Direct link to heading">#</a></h2><p>An attribute like macros allows the creating of a custom attribute that attaches itself to an Item and allows manipulation of that Item. It can also take arguments.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[some_attribute_macro(some_argument)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn perform_task(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// some code</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>In the above code, <code>some_attribute_macros</code> is an attribute macro. It manipulates the function <code>perform_task</code>.</p><p><strong>Writing attribute like macro</strong>
Start by creating a project using <code>cargo new macro-demo</code> <code>--``lib</code>. Once the project is ready to update the <code>Cargo.toml</code> to notify cargo the project will create procedural macros.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain"># Cargo.toml</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[lib]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">proc-macro = true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Now we are all set to venture into procedural macros.</p><p>Procedural macros are public functions that take <code>TokenStream</code> as input and return another <code>TokenStream</code>. For writing procedural macro, we need to write our parser to parse <code>TokenStream</code>. Rust community has a very good crate <code>syn</code> for parsing <code>TokenStream</code>.</p><p><code>syn</code> provides a ready-made parser for Rustlang syntax that can be used to parse <code>TokenStream</code>. You can also parse your syntax by combining low-level parsers providing <code>syn</code>.</p><p>Add <code>syn</code> and <code>quote</code> to <code>Cargo.toml</code></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain"># Cargo.toml</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[dependencies]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">syn = {version=&quot;1.0.57&quot;,features=[&quot;full&quot;,&quot;fold&quot;]}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">quote = &quot;1.0.8&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Now we can write an attribute like a macro in <code>lib.rs</code> using the <code>proc_macro</code> crate provided by the compiler for writing procedural macros. A procedural macro crate cannot export anything else other than procedural macros and procedural macros defined in the crate canâ€™t be used in the crate itself.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// lib.rs</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">extern crate proc_macro;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">use proc_macro::{TokenStream};</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">use quote::{quote};</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// using proc_macro_attribute to declare an attribute like procedural macro</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro_attribute]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// _metadata is argument provided to macro call and _input is code to which attribute like macro attaches</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -&gt; TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // returing a simple TokenStream for Struct</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TokenStream::from(quote!{struct H{}})</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>To test the macro we added, create an ingratiation test by creating a folder named <code>tests</code> and adding file <code>attribute_macro.rs</code> in the folder. Now in this file, we can use our attribute like a macro for testing.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// tests/attribute_macro.rs</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">use macro_demo::*;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// macro converts struct S to struct H</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[my_custom_attribute]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct S{}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[test]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn test_macro(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// due to macro we have struct H in scope</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let demo=H{};</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Run the above test using the <code>cargo test</code> command.
Now that we have some knowledge of procedural macros, lets use <code>syn</code> for some advance <code>TokenStream</code> manipulation and parsing.</p><p>For learning how <code>syn</code> is used for parsing and manipulation, let&#x27;s take an example of <code>syn</code> <a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs" target="_blank" rel="noopener noreferrer">repo</a>. This example creates a macro that trace variables when value changes.</p><p>First, we need to identify how our macro will manipulate the code it attaches.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[trace_vars(a)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn do_something(){</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  let a=9;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  a=6;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  a=0;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The <code>trace_vars</code> macro takes the name of the variable it needs to trace and injects a print statement each time the value of the input variable i.e <code>a</code> changes. It tracks the value of input variables.</p><p>First, parse the code to which the attribute like macro attaches. <code>syn</code> provides an inbuilt parser for Rust function syntax. <code>ItemFn</code> will parse the function and throw an error if the syntax is invalid.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro_attribute]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn trace_vars(_metadata: TokenStream, input: TokenStream) -&gt; TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// parsing rust function to easy to use struct</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let input_fn = parse_macro_input!(input as ItemFn);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TokenStream::from(quote!{fn dummy(){}})</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Now we have the parsed <code>input</code> so let&#x27;s move to <code>metadata</code>. For <code>metadata</code> , no inbuilt parser will work, we will have to write one ourselves for it, using <code>syn</code>&#x27;s <code>parse</code> module.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[trace_vars(a,c,b)] // we need to parse a &quot;,&quot; seperated list of tokens</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// code</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>For <code>syn</code> to work, we need to implement the <code>Parse</code> trait provided by <code>syn</code>. <code>Punctuated</code> is used to create a <code>vector</code> of <code>Indent</code> separated by <code>,</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Args{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    vars:HashSet&lt;Ident&gt;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Parse for Args{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // parses a,b,c, or a,b,c where a,b and c are Indent</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let vars = Punctuated::&lt;Ident, Token![,]&gt;::parse_terminated(input)?;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Ok(Args {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            vars: vars.into_iter().collect(),</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        })</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Once we implement <code>Parse</code> trait we can use <code>parse_macro_input</code> macro for parsing <code>metadata</code>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro_attribute]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn trace_vars(metadata: TokenStream, input: TokenStream) -&gt; TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let input_fn = parse_macro_input!(input as ItemFn);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// using newly created struct Args</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let args= parse_macro_input!(metadata as Args);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TokenStream::from(quote!{fn dummy(){}})</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We will now modify the <code>input_fn</code> to add <code>println!</code> when the variable changes the value. For adding, we need to filter outlines that have an assignment and insert a print statement after that line.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Args {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn should_print_expr(&amp;self, e: &amp;Expr) -&gt; bool {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match *e {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Expr::Path(ref e) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // variable shouldn&#x27;t start wiht ::</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if e.path.leading_colon.is_some() {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    false</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// should be a single variable like `x=8` not n::x=0 </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                } else if e.path.segments.len() != 1 {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    false</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// get the first part</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    let first = e.path.segments.first().unwrap();</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// check if the variable name is in the Args.vars hashset</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    self.vars.contains(&amp;first.ident) &amp;&amp; first.arguments.is_empty()</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            _ =&gt; false,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// used for checking if to print let i=0 etc or not</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn should_print_pat(&amp;self, p: &amp;Pat) -&gt; bool {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match p {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// check if variable name is present in set</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Pat::Ident(ref p) =&gt; self.vars.contains(&amp;p.ident),</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            _ =&gt; false,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// manipulate tree to insert print statement</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn assign_and_print(&amp;mut self, left: Expr, op: &amp;dyn ToTokens, right: Expr) -&gt; Expr {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> // recurive call on right of the assigment statement</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let right = fold::fold_expr(self, right);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// returning manipulated sub-tree</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        parse_quote!({</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            #left #op #right;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            println!(concat!(stringify!(#left), &quot; = {:?}&quot;), #left);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        })</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// manipulating let statement</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn let_and_print(&amp;mut self, local: Local) -&gt; Stmt {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let Local { pat, init, .. } = local;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let init = self.fold_expr(*init.unwrap().1);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// get the variable name of assigned variable</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let ident = match pat {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Pat::Ident(ref p) =&gt; &amp;p.ident,</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            _ =&gt; unreachable!(),</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// new sub tree</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        parse_quote! {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            let #pat = {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                #[allow(unused_mut)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                let #pat = #init;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                println!(concat!(stringify!(#ident), &quot; = {:?}&quot;), #ident);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                #ident</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>In the above example, the <code>quote</code> macro is used for template and writing Rust. <code>#</code> is used for injecting the value of the variable.</p><p>Now we will do a DFS over <code>input_fn</code> and insert the print statement. <code>syn</code> provides a <code>Fold</code> trait that can be implemented for DFS over any <code>Item</code>. We just need to modify the trait methods corresponding to the Token type we want to manipulate.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Fold for Args {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn fold_expr(&amp;mut self, e: Expr) -&gt; Expr {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match e {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// for changing assignment like a=5</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Expr::Assign(e) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// check should print</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if self.should_print_expr(&amp;e.left) {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    self.assign_and_print(*e.left, &amp;e.eq_token, *e.right)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// continue with default travesal using default methods</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    Expr::Assign(fold::fold_expr_assign(self, e))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// for changing assigment and operation like a+=1</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Expr::AssignOp(e) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// check should print</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if self.should_print_expr(&amp;e.left) {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    self.assign_and_print(*e.left, &amp;e.op, *e.right)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// continue with default behaviour</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    Expr::AssignOp(fold::fold_expr_assign_op(self, e))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// continue with default behaviour for rest of expressions</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            _ =&gt; fold::fold_expr(self, e),</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// for let statements like let d=9</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn fold_stmt(&amp;mut self, s: Stmt) -&gt; Stmt {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        match s {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Stmt::Local(s) =&gt; {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if s.init.is_some() &amp;&amp; self.should_print_pat(&amp;s.pat) {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    self.let_and_print(s)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    Stmt::Local(fold::fold_local(self, s))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            _ =&gt; fold::fold_stmt(self, s),</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>Fold</code> trait is used to do a DFS of <code>Item</code>. It allows using different behavior for various Token types.
Now we can use <code>fold_item_fn</code> to inject print statements in our parsed code.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro_attribute]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn trace_var(args: TokenStream, input: TokenStream) -&gt; TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// parse the input</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let input = parse_macro_input!(input as ItemFn);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// parse the arguments</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut args = parse_macro_input!(args as Args);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// create the ouput</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let output = args.fold_item_fn(input);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// return the TokenStream</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TokenStream::from(quote!(#output))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>Note: This code example is from</strong> <code>***syn***</code> <strong>**</strong><a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs" target="_blank" rel="noopener noreferrer"><strong><em>examples</em></strong></a><strong><em>. It is a very good resource to learn about procedural macros.</em></strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="custom-derive-macros"></a>Custom Derive Macros<a class="hash-link" href="#custom-derive-macros" title="Direct link to heading">#</a></h2><p>Custom derive macros allow auto implement traits. These macro allow to implement trait using <code>#[derive(Trait)]</code>. <code>syn</code> has excellent support for <code>derive</code> macros.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[derive(Trait)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct MyStruct{}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>Writing Custom Derive Macros</strong>
We will use <code>DeriveInput</code> for parsing input to derive macro. We will also use the <code>proc_macro_derive</code> macro for defining a custom derive macro.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro_derive(Trait)]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn derive_trait(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let input = parse_macro_input!(input as DeriveInput);</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let name = input.ident;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let expanded = quote! {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        impl Trait for #name {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            fn print(&amp;self) -&gt; usize {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                println!(&quot;{}&quot;,&quot;hello from #name&quot;)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">           }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    proc_macro::TokenStream::from(expanded)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>More advanced procedural macros can be written using <code>syn</code> check out this example from <code>syn</code>&#x27;s <a href="https://github.com/dtolnay/syn/blob/master/examples/heapsize/heapsize_derive/src/lib.rs" target="_blank" rel="noopener noreferrer">repo.</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="function-like-macro"></a>Function Like Macro<a class="hash-link" href="#function-like-macro" title="Direct link to heading">#</a></h2><p>Function-like macros are similar to declarative macros in the way that they are invoked with the macro invocation operator <code>!</code> and look like function calls. They operate on the code that is inside the parentheses.</p><p><strong>Writing Function like macro</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">#[proc_macro]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn a_proc_macro(_input: TokenStream) -&gt; TokenStream {</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TokenStream::from(quote!(</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            fn anwser()-&gt;i32{</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                5</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">))</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Functions like macro are not executed at runtime but at compile time. It can be used anywhere in code. It also takes a <code>TokenStream</code> and returns <code>TokenStream</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="advantage-of-procedural-macros"></a>Advantage of procedural macros<a class="hash-link" href="#advantage-of-procedural-macros" title="Direct link to heading">#</a></h2><ul><li>Better error handling using <code>span</code></li><li>Good control over output</li><li>Good community built crates <code>syn</code> and <code>quote</code></li><li>It is more powerful than declarative macros.</li></ul><header><h1 class="h1Heading_27L5">Conclusion</h1></header><p>In this piece, we learned about macros and different types of macros with the basics of writing both types of macros using various syntax and community built crates. We also learned the advantage of each type of macros.</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/anshulrgoyal/blog/tags/rust">rust</a><a class="margin-horiz--sm" href="/anshulrgoyal/blog/tags/macro">macro</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/anshulrgoyal/blog/deno-plugin"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Â« How to create a Deno plugin in Rust</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/anshulrgoyal/blog/mlh-fellowship"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">MLH Fellowship: A new way of learning Â»</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#creating-declarative-macros" class="table-of-contents__link">Creating Declarative Macros</a></li><li><a href="#using-declarative-macros-for-more-advanced-parsing" class="table-of-contents__link">Using Declarative Macros for more advanced parsing</a></li><li><a href="#limitation-of-declarative-macros" class="table-of-contents__link">Limitation of Declarative Macros</a></li><li><a href="#types-of-procedural-macros" class="table-of-contents__link">Types of Procedural Macros</a></li><li><a href="#attribute-like-macros" class="table-of-contents__link">Attribute like macros</a></li><li><a href="#custom-derive-macros" class="table-of-contents__link">Custom Derive Macros</a></li><li><a href="#function-like-macro" class="table-of-contents__link">Function Like Macro</a></li><li><a href="#advantage-of-procedural-macros" class="table-of-contents__link">Advantage of procedural macros</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">About</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/anshulrgoyal/projects">Contributions</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://dev.to/anshulgoyal15/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Dev.to<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://medium.com/@ar_goyal" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Medium<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/anshul-goyal-8aa479135/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Linkedin<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/ar_goyal" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/anshulrgoyal/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Anshul Goyal. Built with Docusaurus.</div></div></div></footer></div>
<script src="/anshulrgoyal/assets/js/runtime~main.113fc30b.js"></script>
<script src="/anshulrgoyal/assets/js/main.56fd1749.js"></script>
</body>
</html>